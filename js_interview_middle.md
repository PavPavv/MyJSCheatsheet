# Вопросы и ответы на собеседовании по JavaScript (уровень Middle)

## Назовите способы задать свойство объекту

1.

```javascript
const user = {
  firstName: "Paul",
  surname: "Durnov",
  set n(name) {
    this.firstName = name;
  },
  get nameN() {
    return this.firstName;
  },
};

user.getFullName = function () {
  return `${this.firstName} ${this.surname}`;
};

console.log(user.firstName); // 'Paul'
user.n = "Pavel";
console.log(user.nameN); // 'Pavel'
console.log(user.getFullName()); // 'Pavel Durnov'
```

2.

```javascript
const user = {
  firstName: "Paul",
  surname: "Durnov",
  set n(name) {
    this.firstName = name;
  },
  get nameN() {
    return this.firstName;
  },
};

Object.defineProperty(user, "getFullName", {
  get: function () {
    return `${this.firstName} ${this.surname}`;
  },
});

console.log(user.firstName); // 'Paul'
user.n = "Pavel";
console.log(user.nameN); // 'Pavel'
console.log(user.getFullName); // 'Pavel Durnov'
```

**Object.defineProperty(obj, prop, descriptor\*)** позволяет объявить свойство объекта и тонко настроить его особые аспекты.
_descriptor_ - это объект, в котором задаются настройки свойства:

- **value** - значение св-ва, по умолчанию undefined
- **writeable** - true - значение св-ва можно менять, по умолчанию false
- **configurable** - true - можно удалять и менять в дальнейшем, по умолчанию false
- **enumarable** - true - можно просматривать в цикле **for...in** и методе **Object.keys()**. по умолчанию false
- **get** - функция, которая возвращает значения св-ва, по умолчанию undefined
- **set** - функция, которая записывает значения св-ва, по умолчанию undefined
  Если есть **get**/**set**, то **value** и **writeable** не нужно указывать!

## Назовите полезные методы для работы со свойствами объектами

**Object.keys(obj)**
**Object.getOwnPropertyNames(obj)** - возвращает массив со свойствами объектами
**Object.values(obj)**
**Object.entries(obj)**
**Object.fromEntries()** - превращает массив ключей и значений объекта в новый объект
**Object.defineProperty(obj, prop, descriptor)**
**Object.getOwnPropertyDescriptor(obj, prop)**
**Object.create(null)** - создание пустого объекта без прототипа
**Object.create(obj)** - создание объекта, где в качестве прототипа будет переданный аргументом объект

## Что выведет цикл и как исправить код на более ожидаемый последовательный вывод?

```javascript
for (var i = 0; i <= 5; i++) {
  setTimeout(function t() {
    console.log(i);
  }, i * 500);
}

// 6 6 6 6 6 6
```

Самое простое и действенное решение - это просто добавить **let**, так как **let**
имеет блочную область видимости и в циклах создает новую переменную на каждой итерации.

```javascript
for (let i = 0; i <= 5; i++) {
  setTimeout(function t() {
    console.log(i);
  }, i * 500);
}
// 0 1 2 3 4 5
```

Более заковырестое решение без **let** - это оставить **var** и сохранить сохранить
замыкание в модуле IFFE:

```javascript
for (var i = 0; i <= 5; i++) {
  (function () {
    var j = i; // замыкание, каждую итерацию будет создаваться новая переменная с новым значением
    // и выводиться в консоль
    setTimeout(function t() {
      console.log(j);
    }, j * 500);
  })();
}

// 0 1 2 3 4 5
```

## Пример нативного модуля (через замыкание)

```javascript
var MyModules = (function Manager() {
  var modules = {};

  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }

  function get(name) {
    return modules[name];
  }

  return {
    define,
    get,
  };
})();

function funcHello() {
  function hello(who) {
    return "Let me introduce: " + who;
  }

  return {
    hello,
  };
}

function funcBar(bar) {
  var hungry = "hippo";

  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }

  return {
    awesome,
  };
}

MyModules.define("bar", [], funcHello);
MyModules.define("foo", ["bar"], funcBar);

var bar = MyModules.get("bar");
var foo = MyModules.get("foo");

console.log(bar.hello("test"));
```

## Какая разница между лексической ОВ (JS) и динамической (Perl и Emacs Lisp, нет в JS, похожий концепт у this)?

Лексическая область видимости означает, что область видимости определена решениями о том, где объявляются функции на стадии написания кода. Фаза разбиения на лексемы при компиляции фактически способна узнать где и как объявлены все идентификаторы, и таким образом предсказать как их будут искать во время выполнения.
Лексическая область видимости определяется временем написания кода, тогда как динамическая область видимости (и this!) определяется во время выполнения. Лексическую область видимости интересует где функция была объявлена, а динамическую — откуда была вызвана функция.
Все ANGOL3-подобные языки (Pascal, C, C#, Java и др.) используют статические области видимости.

## В чем главное отличие ОВ от this?

Когда функция вызывается, создается запись активации, также известная как **контекст вызова**. Эта запись содержит информацию о том, откуда функция была вызвана (стэк вызова), как функция была вызвана, какие параметры были в неё переданы и т.д. Одним из свойств этой записи является ссылка this, которая будет использоваться на протяжении выполнения этой функции.
**this** — это привязка, которая создается во время вызова функции, и на что она ссылается определяется тем, где и при каких условиях функция была вызвана.

## Что выведет консоль?

```javascript
function foo() {
  console.log(this.a);
}

const obj = {
  a: 2,
  foo,
};

obj.foo(); // 2
```

Какое название вы бы ни выбрали для этого шаблона, в момент когда вызывается _foo()_, ей предшествует объектная ссылка на obj. Когда есть объект контекста для ссылки на функцию, правило неявной привязки говорит о том, что именно этот объект и следует использовать для привязки **this** к вызову функции.
Поскольку _obj_ является this для вызова _foo()_, **this.a** — синоним **obj.a**.
Только верхний/последний уровень ссылки на свойство объекта в цепочке имеет значение для точки вызова.
В отличие от **lexicalEnvironment**, которое создается один раз во время создания функции, **this**(контекст) создается при каждом вызове объявленной функции.

## Что такое стек вызовов (call stack) и как он работает в V8?

JavaScript — однопоточный язык, он использует очередь функций обратного вызова.

V8 - это движок от Google, представлен состоящим из двух основных компонентов:

- Куча (Memory Heap) — то место, где происходит выделение памяти.
- Стек вызовов (Call Stack) — то место, куда в процессе выполнения кода попадают так называемые стековые кадры.

Движок предоставляет для работы с JS цикл событий, очередь функций обратного вызова и Web API.
JavaScript — однопоточный язык программирования. Это означает, что у него один стек вызовов. Таким образом, в некий момент времени он может выполнять лишь какую-то одну задачу.
Стек вызовов — это структура данных, которая, говоря упрощённо, записывает сведения о месте в программе, где мы находимся. Если мы переходим в функцию, мы помещаем запись о ней в верхнюю часть стека. Когда мы из функции возвращаемся, мы вытаскиваем из стека самый верхний элемент и оказываемся там, откуда вызывали эту функцию. Это — всё, что умеет стек. Каждая запись в стеке вызовов называется стековым кадром. На механизме анализа стековых кадров основана информация о стеке вызовов, трассировка стека, выдаваемая при возникновении исключения. Трассировка стека представляет собой состояние стека в момент исключения. Если будет достигнут максимальный размер стека, возникнет так называемое переполнение стека. Произойти такое может довольно просто, например, при необдуманном использовании рекурсии.
Модель выполнения кода в однопоточном режиме облегчает жизнь разработчика. Ему не нужно принимать во внимание сложные схемы взаимодействия программных механизмов, вроде возможности взаимной блокировки потоков, которые возникают в многопоточных окружениях.

## 4 правила определения точки вызова контекста (this)

По увеличению приоритета к концу списка:

1. Пробычно под "наследованием" подразумевается отношение между двумя "классами", а не между "классом" и "экземпляром".ивязка по умолчанию
2. Неявная привязка
3. Явная привязка
4. Привязка **new**

**Привязка по умолчанию**
Когда включен _strict mode_, объект 'global' не подпадает под действие привязки по умолчанию, поэтому в противоположность обычному режиму **this** устанавливается в **undefined**.

```javascript
function foo() {
  console.log(this.a);
}

var a = 2;

foo(); // 2 или undefined в strict mode
```

**Неявная привязка**
Когда есть объект контекста для ссылки на функцию, правило неявной привязки говорит о том, что именно этот объект и следует использовать для привязки this к вызову функции. Поскольку _obj_ является **this** для вызова _foo()_, _this.a_ — синоним _obj.a_.

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
};

obj.foo(); // 2
```

**Явная привязка**

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
};

foo.call(obj); // 2
```

```javascript
function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

var obj = {
  a: 2,
};

var bar = foo.bind(obj);

var b = bar(3); // 2 3
console.log(b); // 5
```

**Привязка new**
В традиционных классо-ориентированных языках, "конструкторы" — это особые методы, связанные с классами, таким образом, что когда создается экземпляр класса с помощью операции new, вызывается конструктор этого класса. На самом деле нет никакой связи с классо-ориентированной функциональностью у той, что предполагает использование new в JS. В JS конструкторы — это всего лишь функции, которые, так уж получилось, были вызваны с операцией new перед ними. Они ни связаны с классами, ни создают экземпляров классов. Они — даже не особые типы функций. Они — всего лишь обычные функции, которые, по своей сути, "украдены" операцией new при их вызове. Нет такой вещи как "функции-конструкторы", а скорее есть вызовы, конструирующие из функций.

Когда функция вызывается с указанием перед ней new, также известный как вызов конструктора, автоматически выполняются следующие вещи:

- Создается новенький объект (т.е. конструируется) прямо из воздуха
- Только что сконструированный объект связывается с "[[Прототипом]]"
- Только что сконструированный объект устанавливается как привязка this для этого вызова функции
- За исключением тех случаев, когда функция возвращает свой собственный альтернативный объект, вызов функции с new автоматически вернет только что сконструированный объект.

**new** — единственный путь, которым this при вызове функции может быть привязан.

```javascript
function test(a) {
  this.a = a;
}

var b = new test("test");
console.log(b.a); // 'test'
```

```javascript
"use strict";
function test(a) {
  this.a = a;
}

const obj = {};
const t = test.bind(obj);

t("v8");
console.log(t); // function test()
console.log(obj); // Object {a: "v8"}
console.log(obj.a); // 'v8'
```

**new** и **call**/**apply** не могут использоваться вместе.
vigil

## Что такое прототипы и прототипное наследование (прототипирование)

Объекты в JavaScript имеют внутреннее свойство, обозначенное в спецификации как _[[Prototype]]_, которое является всего лишь ссылкой на другой объект. Почти у всех объектов при создании это свойство получает не-null значение.
Cтандартное поведение [[Get]] и [[Put]] неприменимо если используются Proxy!
Если стандартная операция [[Get]] не может найти запрашиваемое свойство в самом объекте, то она следует по ссылке [[Prototype]] этого объекта.

В конце каждой типичной цепочки [[Prototype]] находится встроенный объект Object.prototype. Этот объект содержит различные утилиты, используемые в JS повсеместно, поскольку все обычные (встроенные, не связанные с конкретной средой исполнения) объекты в JavaScript "происходят от" объекта Object.prototype (иными словами, имеют его на вершине своей цепочки [[Prototype]]).
****proto**** - это тупо просто свойство, которое показывает и указывает на прототип текущего объекта.

```javascript
"use strict";
const obj = {
  movie: "Interstellar",
};
const obj1 = Object.create(obj); // Object { movie: "Interstellar" }
```

В JavaScript нет абстрактных шаблонов/схем объектов, называемых "классами". В JavaScript просто есть объекты. В JavaScript копирования новых инстансов класса не происходит. Вы не создаете множественные экземпляры класса. Вы можете создать множество объектов, \*связанных** ссылкой [[Prototype]] с общим объектом. Но по умолчанию никакого копирования не происходит, поэтому эти объекты не становятся полностью автономными и не соединенными друг с другом, напротив, они весьма \***связаны\*\*\*.
В JavaScript мы не делаем копии из одного объекта ("класса") в другой ("экземпляр"). Мы создаем ссылки между объектами.
На самом деле new как бы перехватывает любую обычную функцию и вызывает её так, что в результате создается объект, а также выполняется код самой функции. В JavaScript "конструктор" — это любая функция, вызванная с ключевым словом new перед ней.

```javascript
const obj = {
  movie: "Interstellar",
};

const obj1 = {};

console.log(obj1.movie); // undefined
```

```javascript
const obj = {
  movie: "Interstellar",
};

const obj1 = {};
obj1.__proto__ = obj; // подключаем наследование (ссылку на прототип)

console.log(obj1.movie); // 'Interstellar'
```

Object.create(..) создает новый объект (bar), связанный с объектом, который мы указали (foo), и это дает нам всю мощь (делегирование) механизма [[Prototype]], но без ненужных сложностей вроде функции new, выступающей в роли классов и вызовов конструктора, сбивающих с толку ссылок .prototype и .constructor, и прочих лишних вещей.

```javascript
const obj = {
  movie: "Interstellar",
};

const obj1 = Object.create(obj); // подключаем наследование (ссылку на прототип), по сути - это: obj1.__proto__ = obj;

console.log(obj1.movie); // 'Interstellar'
```

тоже самое, но с prototype:

```javascript
const objB = {
  movie: "Interstellar",
};

const objB1 = {};
objB1.prototype = objB;

console.log(obj1.movie); // 'Interstellar'
```

Но обычно под "наследованием" подразумевается отношение между двумя "классами", а не между "классом" и "экземпляром".

```javascript
// пред-ES6
// выбрасывает стандартный существующий `Bar.prototype`
Bar.prototype = Object.create(Foo.prototype);

// ES6+
// изменяет существующий `Bar.prototype`
Object.setPrototypeOf(Bar.prototype, Foo.prototype);
```

По множеству причин, среди которых не последнюю роль играет терминологический прецедент, "наследование" (и "прототипное наследование") и все остальные ОО-термины не имеют смысла, учитывая то как на самом деле работает JavaScript.

Более подходящим термином является "делегирование", поскольку эти связи являются не копиями, а делегирующими ссылками.

## Что происходит "под капотом" у Object.create()

**Object.create(..)** была добавлена в ES5. Вам может понадобиться поддержка пред-ES5 окружения (например, старые версии IE), поэтому давайте рассмотрим простенький частичный полифилл для Object.create(..):

```javascript
if (!Object.create) {
  Object.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
  };
}
```

## Что такое[[Prototype]]?

Это внутренняя ссылка, которая существует в одном объекте и ссылается на другой объект. Эта ссылка используется при обращении к несуществующему свойству/методу первого объекта. В таком случае ссылка [[Prototype]] говорит движку, что свойство/метод нужно искать в связанном объекте. В свою очередь, если поиск в этом объекте завершается неудачно, то происходит переход уже по его ссылке [[Prototype]] и так далее. Эта последовательность ссылок между объектами образует так называемую "цепочку прототипов".
