# Вопросы и ответы на собеседовании по JavaScript (уровень Middle)

## Назовите способы задать свойство объекту

1.

```javascript
const user = {
  firstName: "Albert`",
  surname: "Camus",
  set n(name) {
    this.firstName = name;
  },
  get nameN() {
    return this.firstName;
  },
};

user.getFullName = function () {
  return `${this.firstName} ${this.surname}`;
};

console.log(user.firstName); // 'Albert'
user.n = "Pavel";
console.log(user.nameN); // 'Albert'
console.log(user.getFullName()); // 'Albert Camus'
```

2.

```javascript
const user = {
  firstName: "Paul",
  surname: "Durnov",
  set n(name) {
    this.firstName = name;
  },
  get nameN() {
    return this.firstName;
  },
};

Object.defineProperty(user, "getFullName", {
  get: function () {
    return `${this.firstName} ${this.surname}`;
  },
});

console.log(user.firstName); // 'Paul'
user.n = "Pavel";
console.log(user.nameN); // 'Pavel'
console.log(user.getFullName); // 'Pavel Durnov'
```

**Object.defineProperty(obj, prop, descriptor\*)** позволяет объявить свойство объекта и тонко настроить его особые аспекты.
_descriptor_ - это объект, в котором задаются настройки свойства:

- **value** - значение св-ва, по умолчанию undefined
- **writeable** - true - значение св-ва можно менять, по умолчанию false
- **configurable** - true - можно удалять и менять в дальнейшем, по умолчанию false
- **enumarable** - true - можно просматривать в цикле **for...in** и методе **Object.keys()**. по умолчанию false
- **get** - функция, которая возвращает значения св-ва, по умолчанию undefined
- **set** - функция, которая записывает значения св-ва, по умолчанию undefined
  Если есть **get**/**set**, то **value** и **writeable** не нужно указывать!

## Назовите полезные методы для работы со свойствами объектами

**Object.keys(obj)**
**Object.getOwnPropertyNames(obj)** - возвращает массив со свойствами объектами
**Object.values(obj)**
**Object.entries(obj)**
**Object.fromEntries()** - превращает массив ключей и значений объекта в новый объект
**Object.defineProperty(obj, prop, descriptor)**
**Object.getOwnPropertyDescriptor(obj, prop)**
**Object.create(null)** - создание пустого объекта без прототипа
**Object.create(obj)** - создание объекта, где в качестве прототипа будет переданный аргументом объект

## Что выведет цикл и как исправить код на более ожидаемый последовательный вывод?

```javascript
for (var i = 0; i <= 5; i++) {
  setTimeout(function t() {
    console.log(i);
  }, i * 500);
}

// 6 6 6 6 6 6
```

Самое простое и действенное решение - это просто добавить **let**, так как **let**
имеет блочную область видимости и в циклах создает новую переменную на каждой итерации.

```javascript
for (let i = 0; i <= 5; i++) {
  setTimeout(function t() {
    console.log(i);
  }, i * 500);
}
// 0 1 2 3 4 5
```

Более заковырестое решение без **let** - это оставить **var** и сохранить сохранить
замыкание в модуле IFFE:

```javascript
for (var i = 0; i <= 5; i++) {
  (function () {
    var j = i; // замыкание, каждую итерацию будет создаваться новая переменная с новым значением
    // и выводиться в консоль
    setTimeout(function t() {
      console.log(j);
    }, j * 500);
  })();
}

// 0 1 2 3 4 5
```

## Пример нативного модуля (через замыкание)

```javascript
var MyModules = (function Manager() {
  var modules = {};

  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }

  function get(name) {
    return modules[name];
  }

  return {
    define,
    get,
  };
})();

function funcHello() {
  function hello(who) {
    return "Let me introduce: " + who;
  }

  return {
    hello,
  };
}

function funcBar(bar) {
  var hungry = "hippo";

  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }

  return {
    awesome,
  };
}

MyModules.define("bar", [], funcHello);
MyModules.define("foo", ["bar"], funcBar);

var bar = MyModules.get("bar");
var foo = MyModules.get("foo");

console.log(bar.hello("test"));
```

## Какая разница между лексической ОВ (JS) и динамической (Perl и Emacs Lisp, нет в JS, похожий концепт у this)?

Лексическая область видимости означает, что область видимости определена решениями о том, где объявляются функции на стадии написания кода. Фаза разбиения на лексемы при компиляции фактически способна узнать где и как объявлены все идентификаторы, и таким образом предсказать как их будут искать во время выполнения.
Лексическая область видимости определяется временем написания кода, тогда как динамическая область видимости (и this!) определяется во время выполнения. Лексическую область видимости интересует, где функция была объявлена, а динамическую — откуда была вызвана функция.
Все ALGOL-подобные языки (Pascal, C, C#, Java и др.) используют статические области видимости.

## В чем главное отличие ОВ от this?

Когда функция вызывается, создается запись активации, также известная как **контекст вызова**. Эта запись содержит информацию о том, откуда функция была вызвана (стэк вызова), как функция была вызвана, какие параметры были в неё переданы и т.д. Одним из свойств этой записи является ссылка this, которая будет использоваться на протяжении выполнения этой функции.
**this** — это привязка, которая создается во время вызова функции, и на что она ссылается определяется тем, где и при каких условиях функция была вызвана.

## Что выведет консоль?

```javascript
function foo() {
  console.log(this.a);
}

const obj = {
  a: 2,
  foo,
};

obj.foo(); // 2
```

Какое название вы бы ни выбрали для этого шаблона, в момент когда вызывается _foo()_, ей предшествует объектная ссылка на obj. Когда есть объект контекста для ссылки на функцию, правило неявной привязки говорит о том, что именно этот объект и следует использовать для привязки **this** к вызову функции.
Поскольку _obj_ является **this** для вызова _foo()_, **this.a** — синоним **obj.a**.
Только верхний/последний уровень ссылки на свойство объекта в цепочке имеет значение для точки вызова.
В отличие от **lexicalEnvironment**, которое создается один раз во время создания функции, **this**(контекст) создается при каждом вызове объявленной функции.

## Что такое стек вызовов (call stack) и как он работает в V8?

JavaScript — однопоточный язык с динамической типизацией, он использует очередь функций обратного вызова.

V8 - это движок от Google, представлен состоящим из двух основных компонентов:

- Куча (Memory Heap) — то место, где происходит выделение памяти.
- Стек вызовов (Call Stack) — то место, куда в процессе выполнения кода попадают так называемые стековые кадры.

Движок предоставляет для работы с JS цикл событий, очередь функций обратного вызова и Web API.
JavaScript — однопоточный язык программирования. Это означает, что у него один стек вызовов. Таким образом, в некий момент времени он может выполнять лишь какую-то одну задачу.
Стек вызовов — это структура данных, которая, говоря упрощённо, записывает сведения о месте в программе, где мы находимся. Если мы переходим в функцию, мы помещаем запись о ней в верхнюю часть стека. Когда мы из функции возвращаемся, мы вытаскиваем из стека самый верхний элемент и оказываемся там, откуда вызывали эту функцию. Это — всё, что умеет стек. Каждая запись в стеке вызовов называется стековым кадром. На механизме анализа стековых кадров основана информация о стеке вызовов, трассировка стека, выдаваемая при возникновении исключения. Трассировка стека представляет собой состояние стека в момент исключения. Если будет достигнут максимальный размер стека, возникнет так называемое переполнение стека. Произойти такое может довольно просто, например, при необдуманном использовании рекурсии.
Модель выполнения кода в однопоточном режиме облегчает жизнь разработчика. Ему не нужно принимать во внимание сложные схемы взаимодействия программных механизмов, вроде возможности взаимной блокировки потоков, которые возникают в многопоточных окружениях.

## 4 правила определения точки вызова контекста (this)

По увеличению приоритета к концу списка:

1. Привязка по умолчанию
2. Неявная привязка
3. Явная привязка
4. Привязка **new**

**Привязка по умолчанию**
Когда включен _strict mode_, объект 'global' не подпадает под действие привязки по умолчанию, поэтому в противоположность обычному режиму **this** устанавливается в **undefined**.

```javascript
function foo() {
  console.log(this.a);
}

var a = 2;

foo(); // 2 или undefined в strict mode
```

**Неявная привязка**
Когда есть объект контекста для ссылки на функцию, правило неявной привязки говорит о том, что именно этот объект и следует использовать для привязки this к вызову функции. Поскольку _obj_ является **this** для вызова _foo()_, _this.a_ — синоним _obj.a_.

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
};

obj.foo(); // 2
```

**Явная привязка**

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
};

foo.call(obj); // 2
```

```javascript
function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

var obj = {
  a: 2,
};

var bar = foo.bind(obj);

var b = bar(3); // 2 3
console.log(b); // 5
```

**Привязка new**
В традиционных классо-ориентированных языках, "конструкторы" — это особые методы, связанные с классами, таким образом, что когда создается экземпляр класса с помощью операции new, вызывается конструктор этого класса. На самом деле нет никакой связи с классо-ориентированной функциональностью у той, что предполагает использование new в JS. В JS конструкторы — это всего лишь функции, которые, так уж получилось, были вызваны с операцией new перед ними. Они ни связаны с классами, ни создают экземпляров классов. Они — даже не особые типы функций. Они — всего лишь обычные функции, которые, по своей сути, "украдены" операцией new при их вызове. Нет такой вещи как "функции-конструкторы", а скорее есть вызовы, конструирующие из функций.

Когда функция вызывается с указанием перед ней new, также известный как вызов конструктора, автоматически выполняются следующие вещи:

- Создается новенький объект (т.е. конструируется) прямо из воздуха
- Только что сконструированный объект связывается с "[[Прототипом]]"
- Только что сконструированный объект устанавливается как привязка **this** для этого вызова функции
- За исключением тех случаев, когда функция возвращает свой собственный альтернативный объект, вызов функции с **new** автоматически вернет только что сконструированный объект.

**new** — единственный путь, которым this при вызове функции может быть привязан.

```javascript
function test(a) {
  this.a = a;
}

var b = new test("test");
console.log(b.a); // 'test'
```

```javascript
"use strict";
function test(a) {
  this.a = a;
}

const obj = {};
const t = test.bind(obj);

t("v8");
console.log(t); // function test()
console.log(obj); // Object {a: "v8"}
console.log(obj.a); // 'v8'
```

**new** и **call**/**apply** не могут использоваться вместе.
vigil

## Что такое прототипы и прототипное наследование (прототипирование)

Объекты в JavaScript имеют внутреннее свойство, обозначенное в спецификации как [[Prototype]], которое является всего лишь ссылкой на другой объект. Почти у всех объектов при создании это свойство получает не-null значение.
Cтандартное поведение [[Get]] и [[Put]] неприменимо если используются Proxy!
Если стандартная операция [[Get]] не может найти запрашиваемое свойство в самом объекте, то она следует по ссылке [[Prototype]] этого объекта.

В конце каждой типичной цепочки [[Prototype]] находится встроенный объект Object.prototype. Этот объект содержит различные утилиты, используемые в JS повсеместно, поскольку все обычные (встроенные, не связанные с конкретной средой исполнения) объекты в JavaScript "происходят от" объекта Object.prototype (иными словами, имеют его на вершине своей цепочки [[Prototype]]). \***\*proto\*\*** - это тупо просто свойство, которое показывает, устанавливает и указывает на прототип текущего объекта.

```javascript
"use strict";
const obj = {
  movie: "Interstellar",
};
const obj1 = Object.create(obj); // Object { movie: "Interstellar" }
```

В JavaScript нет абстрактных шаблонов/схем объектов, называемых "классами". В JavaScript просто есть объекты. В JavaScript копирования новых инстансов класса не происходит. Вы не создаете множественные экземпляры класса. Вы можете создать множество объектов, \*связанных** ссылкой [[Prototype]] с общим объектом. Но по умолчанию никакого копирования не происходит, поэтому эти объекты не становятся полностью автономными и не соединенными друг с другом, напротив, они весьма \***связаны\*\*\*.
В JavaScript мы не делаем копии из одного объекта ("класса") в другой ("экземпляр"). Мы создаем ссылки между объектами.
На самом деле **new** как бы перехватывает любую обычную функцию и вызывает её так, что в результате создается объект, а также выполняется код самой функции. В JavaScript "конструктор" — это любая функция, вызванная с ключевым словом **new** перед ней.

```javascript
const obj = {
  movie: "Interstellar",
};

const obj1 = {};

console.log(obj1.movie); // undefined
```

нет наследования

```javascript
const obj = {
  movie: "Interstellar",
};

const obj1 = {};
obj1.__proto__ = obj; // подключаем наследование (ссылку на прототип)

console.log(obj1.movie); // 'Interstellar'
```

c **proto**

```javascript
const obj = {
  movie: "Interstellar",
};

const obj1 = Object.create(obj); // подключаем наследование (ссылку на прототип), по сути - это: obj1.__proto__ = obj;

console.log(obj1.movie); // 'Interstellar'
```

Object.create(..) создает новый объект (bar), связанный с объектом, который мы указали (foo), и это дает нам всю мощь (делегирование) механизма [[Prototype]], но без ненужных сложностей вроде функции new, выступающей в роли классов и вызовов конструктора, сбивающих с толку ссылок .prototype и .constructor, и прочих лишних вещей.

```javascript
const objB = {
  movie: "Interstellar",
};

const objB1 = {};
objB1.prototype = objB;

console.log(obj1.movie); // 'Interstellar'
```

тоже самое, но с prototype:

Но обычно под "наследованием" подразумевается отношение между двумя "классами", а не между "классом" и "экземпляром".

```javascript
// пред-ES6
// выбрасывает стандартный существующий `Bar.prototype`
Bar.prototype = Object.create(Foo.prototype);

// ES6+
// изменяет существующий `Bar.prototype`
Object.setPrototypeOf(Bar.prototype, Foo.prototype);
```

По множеству причин, среди которых не последнюю роль играет терминологический прецедент, "наследование" (и "прототипное наследование") и все остальные ОО-термины не имеют смысла, учитывая то, как на самом деле работает JavaScript.

Более подходящим термином является "делегирование", поскольку эти связи являются не копиями, а делегирующими ссылками.

## Что происходит "под капотом" у Object.create()

**Object.create(..)** была добавлена в ES5. Вам может понадобиться поддержка пред-ES5 окружения (например, старые версии IE), поэтому давайте рассмотрим простенький частичный полифилл для Object.create(..):

```javascript
if (!Object.create) {
  Object.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
  };
}
```

## Что такое prototype?
Особое свойство, оно работает с оператором **new**. Ссылка на объект-прототип копируется во внутреннее свойство [[Prototype]] нового объекта.

## Что такое внутреннее [[Prototype]]?

Это внутренняя ссылка, которая существует в одном объекте и ссылается на другой объект. Эта ссылка используется при обращении к несуществующему свойству/методу первого объекта. В таком случае ссылка [[Prototype]] говорит движку, что свойство/метод нужно искать в связанном объекте. В свою очередь, если поиск в этом объекте завершается неудачно, то происходит переход уже по его ссылке [[Prototype]] и так далее. Эта последовательность ссылок между объектами образует так называемую "цепочку прототипов".

## Что такое __proto__ ?
Это нереккомендуемое свойство назначения [[Prototype]] объекта объекта, от которого
будет происходить наследование свойств. Лучше использовать **Object.create(obj)**,
если необходимо реализовать явное наледование объекта (не конструктора, не класса , а имеено объекта);
К слову, Кайл Симпсон в своей книге _Вы не знаете JS: this и Прототипы Объектов_
прямо призывает изспользовать явное прототипное наследование без конструкторов и
**__proto__**, **prototype**, а с **Object.create(obj)** везде.

Это геттер/сеттер для **Object.prototype**.
```javascript
console.log([].__proto__) // Array[] concat(), constructor(), ..., pop(), ...

const obj1 = { test: '1' };
const obj2 = { noTest: '2' };
obj2.__proto__ = obj1;
console.log(obj2.test)  //  '1' (подключенное наследование)
console.log(obj2.__proto__) // { test: '1' } 
```
Также, если просто вызвать толко данное свойство с объектом, то получим объект-шаблон,
от которого наследуется объект, на котором вызвано свойство **__proto__**

## Удалит ли оператор delete в объекте свойство, которое тот наследует от другого объекта?

Нет. Важно понимать, что прототипное наследование работает только, когда мы пытаемся получить доступ к свойству объекта. При явном присвоении или удаление свойства объекта, прототипная цепочка не задействуется.
```javascript
const football = {
  main: 'ball',
};

const brasil = Object.create(football);
brasil.player = 'Ronaldo';
delete brasil.main;
console.log(brasil.player); //  'Ronaldo'
console.log(brasil.main);  //  'ball'
```

## Что такое "движок" JS?

Движок JS сам по себе не обладает внутренним чувством времени, но он становится
средой исполнения для любого произвольного фрагмента JS. Планирование «событий»
(выполнений фрагментов кода JS) всегда осуществляется окружающей средой.

```javascript
// `eventLoop` - массив, работающий по принципу очереди
// (первым пришел, первым вышел)
var eventLoop = [ ];
var event;
// продолжать "бесконечно"
while (true) {
  // отработать "квант"
  if (eventLoop.length > 0) {
    // получить следующее событие в очереди
    event = eventLoop.shift();
    }
  }
  // выполнить следующее событие
  try {
    event();
    }
  catch (err) {
    reportError(err);
    }
  }
}
```

Каждая итерация цикла называется тиком. В каждом тике, если в очереди ожидает событие, оно, событие,
извлекается и выполняется. Этими событиями становятся ваши функции обратного вызова.
Cуть асинхронности — управление промежутком между «сейчас» и «потом». Параллелизм обозначает
возможность одновременного выполнения операций. Самые распространенные средства
организации параллельных вычислений — процессы и потоки (threads). Процессы и потоки
выполняются независимо и могут выполняться одновременно на разных процессорах и даже на разных компьютерах, но несколько потоков могут совместно использовать общую память одного процесса. С другой стороны,
цикл событий разбивает свою работу на задачи и выполняет их последовательно, что
делает невозможным параллельный доступ и изменения в общей памяти. Параллелизм и
последовательность не могут совместно существовать в форме
взаимодействующих циклов событий в разных потоках.
Однопоточный цикл событий — одно из выражений концепции параллельного выполнения.

## Что такое индемпотентность?

Идемпоте́нтность (лат. idem — тот же самый + potens — способный) — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом. Термин предложил американский математик Бенджамин Пирс (англ. Benjamin Peirce) в статьях 1870-х годов.

## Известные методы http(s)-запросов?

GET, POST, PUT, PATCH, DELETE, TRACE.

## В чем разница между POST, PUT и PACTCH?

**PUT** меняет объект целиком. **PUT** создает новый ресурс или заменяет представление
целевого ресурса, данными представленными в теле запроса. (Переписывает).

**PATCH** используется для частичного изменения ресурса. (Смерживает).

**POST**:
Разница между **PUT** и **POST** - это вопрос семантики. Коль скоро для операций используются разные глаголы, то и смысл у них должен быть разным.
Представьте, что ваш сервис оперирует понятиями блокнот (notebook) и запись (post). Один блокнот может содержать множество записей.
Для добавления новой записи в блокнот c идентификатором id вы будете использовать метод **POST** с URL mydomain/notebooks/id/. Ваш сервис, ориентируясь на метод **POST**, сам присвоит нужный идентификатор записи, добавит ее в блокнот и вернет вам URL созданной записи (для доступа к записи по **GET** или для удаления по **DELETE**). При этом хорошо бы вернуть клиенту URL созданной записи.
Допустим, запись с идентификатором post-id уже создана и доступна по URL mydomain/notebooks/id/posts/post-id. Но клиент (владелец записи) исправил в ней ошибку и хочет перезаписать ее. Для этого он использует метод **PUT** с URL mydomain/notebooks/id/posts/post-id и передает обновленную запись в теле запроса. Ваш сервис, ориентируясь на метод PUT удаляет старую запись и записывает новую, при этом она доступна по тому же URL.
Конечно, никто не мешает вам всегда использовать метод **POST** (например HTML4 позволял использовать только методы GET и POST). Но все же стоит придерживаться рекомендаций в целях единообразной трактовки методов всеми разработчиками.
UPD: Рекомендуется использоваться метод **POST** для создания подчиненного ресурса (дочернего по отношению к другому ресурсу; пример блокнота и записи как раз очень подходит).

## Что такое SOLID?

Роберт Мартин, для того, чтобы помочь всем желающим разрабатывать качественные ООП-приложения, разработал пять принципов объектно-ориентированного программирования и проектирования, говоря о которых, с подачи Майкла Фэзерса, используют акроним SOLID.

Вот как расшифровывается акроним SOLID:

S: Single Responsibility Principle (Принцип единственной ответственности).
(Класс должен быть ответственен лишь за что-то одно.)

O: Open-Closed Principle (Принцип открытости-закрытости).
(Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.)

L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
(Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. )

I: Interface Segregation Principle (Принцип разделения интерфейса).
(Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента(класса, компонента). Клиенты не должны зависеть от интерфейсов, которые они не используют.)

D: Dependency Inversion Principle (Принцип инверсии зависимостей).
(Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.)

## Как происходит процесс рендера в браузере?

Объектная модель документа DOM создаётся в тот момент, когда браузер парсит HTML. Этот HTML может запрашивать JavaScript, который может модифицировать DOM. HTML может запросить стили, которые участвуют в создании CSS Object Model. Движок браузера комбинирует эти две объектные модели, чтобы создать дерево рендера (**render tree**). Компоновка (**layout**) определяет размеры и позицию каждого элемента на странице. Как только компоновка определена - пиксели отрисовываются на экране.

Загрузка веб-страницы или приложения начинается с запроса HTML. Сервер возвращает HTTP-ответ, состоящий из заголовков (**headers**) и тела запроса. Именно в теле запроса содержится HTML-документ. Браузер начинает парсить загружаемый HTML, преобразуя полученные байты документа в DOM-дерево. Браузер создаёт новый запрос каждый раз, когда он находит ссылки на внешние ресурсы, будь то файлы стилей, скриптов или ссылки на изображения. Некоторые запросы являются блокирующими. Это означает, что пока такие запросы выполняются - другие запросы приостанавливаются. Браузер продолжает парсить HTML и создавать DOM до тех пор, пока запрос на получение HTML не подходит к концу. После завершения парсинга DOM, браузер конструирует CSS модель. Как только эти модели сформированы, браузер строит дерево рендера (**render tree**), в котором вычисляет стили для каждого видимого элемента страницы. После формирования дерева происходит компоновка (**layout**), которая определяет положение и размеры элементов этого дерева. Как только этап завершён - страница рендерится. Или "отрисовывается" (**paint**) на экране.

**DOM**
Построение DOM инкрементально. Ответ в виде HTML превращается в токены, которые превращаются в узлы (nodes), которые формируют DOM дерево. Простейший узел начинается с startTag-токена и заканчивается токеном endTag. Узлы содержат всю необходимую информацию об HTML-элементе, соответствующем этому узлу. Узлы (nodes) связаны с Render Tree с помощью иерархии токенов: если какой-то набор startTag и endTag-токенов появляется между уже существующим набором токенов, мы получаем узел (node) внутри узла (node), то есть получаем иерархию дерева DOM.
Чем больше количество узлов (node) имеет приложение, тем дольше происходит формирование DOM tree, а значит дольше происходит обработка критических этапов рендеринга.

**CSSOM**
DOM несёт в себе всё содержимое страницы. CSSOM содержит все стили страницы, то есть данные о том, как стилизовать DOM. CSSOM похож на DOM, но всё же отличается. Если формирование DOM инкрементально, CSSOM - нет. CSS блокирует рендер: браузер блокирует рендеринг страницы до тех пор, пока не получит и не обработает все CSS-правила. CSS блокирует рендеринг, потому что правила могут быть перезаписаны, а значит, необходимо дождаться построения CSSOM, чтобы убедиться в отсутствии дополнительных переопределений.

У CSS имеются свои правила валидации токенов. Помните, что C в CSS означает "Cascade". CSS-правила ниспадают каскадом. Иными словами, когда парсер преобразует токены в узлы (nodes), вложенные узлы наследуют стили от родительских. Инкрементальная обработка недоступна для CSS, потому что набор следующих правил может перезаписать предыдущие. Объектная модель CSS (CSSOM) строится по мере парсинга CSS, но она не может быть использована для построения дерева рендера (render tree), потому что может оказаться так, что следующий набор правил может сделать какой-либо из узлов дерева невидимым на экране. Это может привести к лишнему вызову компоновки и перерасчёта стилей.

Говоря о производительности селекторов (selector), наименее специфичные селекторы срабатывают быстрее. Например, .foo {} сработает быстрее .bar .foo {}. В первом случае, условно, понадобится одна операция, чтобы найти элемент .foo, во втором случае, сначала будут найдены все .foo, а потом браузер пройдёт вверх по дереву в поисках родительского элемента .bar. Более специфичные селекторы требуют от браузера большего количества работы, но эти проблемы, вероятно, не стоят их оптимизации.

Если вы измерите время, требуемое на парсинг CSS, вы будете удивлены тем, как быстро работают браузеры. Более специфичные правила более затратны, потому что требуют обхода большего числа узлов в DOM дереве, но эта дороговизна обходится довольно дёшево, особенно в сравнении с другими узкими местами производительности. Сначала измеряйте. Потом оптимизируйте, если это действительно необходимо. Вероятно, специфичность селекторов не то, что действительно затормаживает ваше приложение. Когда дело доходит до оптимизации CSS, улучшение производительность селекторов ускоряет рендеринг лишь на микросекунды.

**Render tree**
Дерево рендера охватывает сразу и содержимое страницы, и стили: это место, где DOM и CSSOM деревья комбинируются в одно дерево. Для построения дерева рендера браузер проверяет каждый узел (node) DOM, начиная от корневого (root) и определяет, какие CSS-правила нужно присоединить к этому узлу.
Дерево рендера охватывает только видимое содержимое. Например, секция head (в основном) не содержит никакой видимой информации, а потому может не включаться в дерево. Кроме того, если у какого-то узла стоит свойство display: none, оно так же не включается в дерево (как и потомки этого узла).

**Layout**
В тот момент, когда дерево рендера (**render tree**) построено, становится возможным этап компоновки (**layout**). Компоновка зависит от размеров экрана. Этот этап определяет, где и как на странице будут спозиционированы элементы и каковы связи между элементами.
Мета тэг **viewport**, который вы можете указать в **head** страницы, определяет ширину видимой области и влияет на компоновку. Без этого тэга браузеры используют ширину "по умолчанию", которая обычно составляет 960px. В браузерах, открывающихся по умолчанию в полноэкранном режиме, например, в браузере телефона, установка тега **<meta name="viewport" content="width=device-width">** установит ширину видимой области в 100% от ширины экрана устройства, вместо того, чтобы использовать ширину по умолчанию. Эта ширина (device-width) изменяется каждый раз, когда пользователь поворачивает телефон. Это приводит к запуску этапа компоновки. Равно как и при изменении размеров окна в обычном браузере.
На производительность компоновки (layout) непосредственно влияет DOM - чем больше узлов (nodes) в вашем документе, тем больше времени понадобится на перерасчёт позиций и размеров всех элементов. Компоновка может стать узким местом, ведущим к зависаниям, особенно если выполняется одновременно со скроллом или другой анимацией. И хотя задержка 20мс при загрузке или переориентации экрана может быть приемлемой, это всё равно может привести к подвисаниям при анимации и скролле. Каждый раз, когда дерево рендера (render tree) модифицируется, например, из-за добавления узла (node), его модификации или при изменении стилей box-модели, запускается компоновка.
Для уменьшения частоты и продолжительности этого этапа, группируйте обновления экрана и избегайте анимации свойств, связанных с box-моделью элементов.

**Paint**
Последний этап в нашем списке - отрисовка (paint) пикселей на экране. Когда дерево рендера (render tree) создано, компоновка (layout) произошла, пиксели могут быть отрисованы. При первичной загрузке документа (onload) весь экран будет отрисован. После этого будут перерисовываться только необходимые к обновлению части экрана, так как браузер старается оптимизировать процесс отрисовки, избегая ненужной работы. Так, если у вас в документе есть два элемента, перерисовываться будет только тот, который вы изменили. Время отрисовки зависит от того, какой тип обновления применился к дереву рендера (render tree). И хотя отрисовка - это очень быстрый процесс, и он, вероятно, слабо влияет на производительность, очень важно помнить, что оба этапа - компоновка (layout) и отрисовка (paint) должны работать сообща и укладываться в частоту обновления кадров. Каждое CSS-свойство, применяемое к любому узлу (node) увеличивает время отрисовки, но полное удаление стиля, способное сэкономить вам 0.001мс, вряд ли даст вам желаемый результат, но зато с лёгкостью ухудшит пользовательский опыт. Помните - сначала нужно измерять, а потом оптимизировать только необходимое!

## Что такое diffing в React?

**Diffing** - это сравнение **DOM**. После создания виртуального DOM, React сравнивает это новое представление со снимком предыдущей версии для определения изменившихся элементов.
После определения различий, React обновляет только те объекты браузерного DOM, которые подверглись изменениям, после чего браузер перерисовывает эти объекты. После следующего изменения состояния или пропов компонента, создается новый виртуальный DOM и процесс повторяется.
Процесс определения различий между новым виртуальным DOM и старым называется diffing. Для сравнения используется эвристический алгоритм со сложностью O(n). В процессе сравнения React вычисляет минимальное количество операций, необходимых для обновления браузерного DOM, игнорируя ненужные изменения. Данный процесс также именуется reconciliation (согласованием).
React реализует эвристический O(n) алгоритм, основываясь на двух допущениях:

- Элементы разного типа приводят к формированию разных деревьев
- Разработчик может пометить определенные элементы как стабильные с помощью пропа key
