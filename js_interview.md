Вопросы и ответы на собеседовании по JavaScript
===============================================

Типы данных в JS
-----------------
В JS существует **8** типов данных: 7 примитивов (**boolean**, **string**, **number**, **bigInt**, **Symbol**, **undefined**, **null**) и 
1 ссылочный тип: **object**. Также в JS есть такое понятие, как псевдоложные значения, которые при привидении их к булевому типу 
вернут *false*. Их тоже 7: **false**, **0**, **-0**, **''**, **undefined**, **null** и **NaN**.


Чем отличается undefined от null
--------------------------------
**undefined** представляет собой значение по умолчанию:
* переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;
* функции, которая ничего не возвращает явно, например, *console.log(1)*;
* несуществующего свойства объекта;

**null** — это «значение отсутствия значения». Это значение, которое присваивается переменной явно.
При сравнении **null** и **undefined** мы получаем *true*, когда используем оператор "==", и *false* при использовании оператора "==="
(сравнение по типу).




Оператор логическое 'И' **&&**
------------------------------
Может применяться как аналог управляющей инструкции **if**, так как **&&** находит и возвращает первое ложное значение,
либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат.
```javascript
true && console.log('Вывод');
```
Такой код вернет "Вывод".
Основные логические операторы в JS - **&&**, **||** (логическое "ИЛИ"), **!** (логическое отрицание ("НЕ")).
Оператор **&&** старше, чем **||**.



Виды преобразований в JS
------------------------
* ToBoolean
* ToString
* ToNumber
* ToPrimitive
* JSON.stringify() - не совсем преобразование

###### ToBoolean
Кроме 7 псевдоложных значений, все *true*.
**Boolean()**, **!!**, **if**, **for**, **while**, **do/while**, **? :**,
левая часть **&&**, **||**

###### ToString
**''**, **""**, **``**, stringType + something, **String()**, **toString()**

###### ToNumber
+, **Number()**, **parseInt()** 

true/false == 1/0
'' == 0
```javascript
let test = undefined + 5;
console.log(test)
console.log(typeof (test))
```
*Вернет **NaN** и тип будет **number***

###### ToPrimitive
valueOf -> toString()



Что такое DOM?
--------------
Document Object Model - это API браузера для работы с HTML- и XML-документами.
DOM представляет собой древовидную структуру (дерево документа). DOM используется 
для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.



В чем разница между event.target и event.currentTarget
------------------------------------------------------
**event.target** — это элемент, в котором происходит событие, или элемент, вызвавший событие.
**event.currentTarget** — это элемент, к которому прикреплен прослушиватель событий.



Чем отличаются "==" и "==="
---------------------------
"==" сравнивает с неявным приведеннием к типу, "===" сравнивает по типу.
Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная.


Что такое всплытие события?
-----------------------------
Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), 
переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, 
пока не достигает объекта Window.

Что такое поднятие (Hoisting)?
---------------------------------
Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.
В фазе компиляции функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined 
поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. 
Это объясняет, почему мы можем вызывать функции до их объявления. В фазе выполнения переменным присваиваются значения, а функции
(или методы объектов) вызываются или выполняются.
*Поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова **«var»**.*


Область видимости
--------------------
Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: 
глобальная, функциональная и блочная (ES6).
**Глобальная** область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости 
и доступны из любого места в коде.
**Функциональная** область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, 
доступны только внутри этой функции.
**Блочная** область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.

Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, 
ее поиск производится выше, во внешней по отношению к текущей области видимости (замыкание). Если и во внешней области видимости переменная отсутствует, ее 
поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет 
— выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. 
Это называется цепочкой областей видимости (Scope Chain).
Изнутри наружу: дети видят родителей, родители не видят детей.


Замыкание (Closure)
-----------------------
Замыкание - это функция, использующая переменные из внешней области видимости. По сути, это функция внутри функции.
Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, 
замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый 
раз при создании функции, во время её создания.

##### Более подробно:
В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, 
называемый лексическим окружением LexicalEnvironment. Объект лексического окружения состоит из двух частей:

* Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
* Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

**Переменная – это просто свойство специального внутреннего объекта: Environment Record. Получить или изменить переменную», означает,** 
**получить или изменить свойство этого объекта**.

Один вызов – одно лексическое окружение. Лексическое окружение – это специальный внутренний объект.
Все функции «при рождении» получают скрытое свойство **[[Environment]]**, которое ссылается на лексическое окружение места, где они были созданы.

Пример работы use strict
----------------------------
* Нельзя присваивать значения или обращаться к необъявленным переменным
* Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи
* Нельзя удалить «неудаляемое» свойство объекта
* Запрещено дублирование параметров
* Нельзя создавать функции с помощью функции eval
* Значением «this» по умолчанию является undefined
* прочее...


This
----
this - это объект перед точкой. Значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this.
Для доступа к информации внутри объекта метод может использовать ключевое слово this. Значение this – это объект «перед точкой», 
который использовался для вызова метода. В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования.
Значение this вычисляется во время выполнения кода и зависит от контекста. Вызов без объекта: this == undefined. Стрелочные функции особенные: 
у них нет своего «собственного» this. Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.
В JavaScript this является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, 
а зависит от того, какой объект вызывает метод (какой объект стоит «перед точкой»).
