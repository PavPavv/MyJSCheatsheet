# Вопросы и ответы на собеседовании по JavaScript (уровень Middle)

## 1. Назовите способы задать свойство объекту

1. Напрямую обратиться к объекту:

```javascript
const user = {
  firstName: 'Albert`',
  surname: 'Camus',
};
user.phone = '89374565434';
console.log(user);
```

2. Прописать свойство через нативные методы объекта **set**/**get**

```javascript
const user = {
  firstName: 'Albert`',
  surname: 'Camus',
  set n(name) {
    this.firstName = name;
  },
  get nameN() {
    return this.firstName;
  },
};

user.getFullName = function () {
  return `${this.firstName} ${this.surname}`;
};

console.log(user.firstName); // 'Albert'
user.n = 'Pavel';
console.log(user.nameN); // 'Albert'
console.log(user.getFullName()); // 'Albert Camus'
```

3. Встроенное глобальное свойство **defineProperty(obj, prop, {descriptor})**

```javascript
const user = {
  firstName: 'Paul',
  surname: 'Durnov',
  set n(name) {
    this.firstName = name;
  },
  get nameN() {
    return this.firstName;
  },
};

Object.defineProperty(user, 'getFullName', {
  get: function () {
    return `${this.firstName} ${this.surname}`;
  },
});

console.log(user.firstName); // 'Paul'
user.n = 'Pavel';
console.log(user.nameN); // 'Pavel'
console.log(user.getFullName); // 'Pavel Durnov'
```

**Object.defineProperty(obj, prop, descriptor\*)** позволяет объявить свойство объекта и тонко настроить его особые аспекты.
_descriptor_ - это объект, в котором задаются настройки свойства:

- **value** - значение св-ва, по умолчанию undefined
- **writeable** - true - значение св-ва можно менять, по умолчанию false
- **configurable** - true - можно удалять и менять в дальнейшем, по умолчанию false
- **enumarable** - true - можно просматривать в цикле **for...in** и методе **Object.keys()**. по умолчанию false
- **get** - функция, которая возвращает значения св-ва, по умолчанию undefined
- **set** - функция, которая записывает значения св-ва, по умолчанию undefined
  Если есть **get**/**set**, то **value** и **writeable** не нужно указывать!

## 2. Назовите полезные методы для работы со свойствами объекта

- **Object.keys(obj)** - возвращает ключи объекта в виде массива
- **Object.getOwnPropertyNames(obj)** - возвращает массив со свойствами объектами (не учитывая наследование)
- **Object.values(obj)** - возвращает значение ключей объекта
- **Object.entries(obj)** - возвращает массив связок ключей с их свойствами из объекта ([['k', 'v'],['k1', 'v1'],...])
- **Object.fromEntries()** - превращает массив ключей и значений объекта в новый объект (const arr = [["0", "a"],["1", "b"],["2", "c"],]; const obj = Object.fromEntries(arr); // { 0: "a", 1: "b", 2: "c" })
- **Object.defineProperty(obj, prop, descriptor)** - тонкая настройка свойств объекта
- **Object.getOwnPropertyDescriptor(obj, prop)** - возвращает подробное описание настроек указанного свойста в указанном объекте
- **Object.create(null)** - создание пустого объекта без прототипа
- **Object.create(obj)** - создание объекта, где в качестве прототипа будет переданный аргументом объект, второй, опциональный аргумент - стандартный дескриптор для ручной настройки свойства

## 3. Что выведет цикл и как исправить код на более ожидаемый последовательный вывод?

```javascript
for (var i = 0; i < 10; i++) {
  setTimeout(function t() {
    console.log(i);
  }, i * 500);
}

// 10 10 10 10 10 10 10 10 10 10
```

Поскольку **var** не имеет блочной области видимости (только функциональная и глобальная), в итоге будет создана только одна переменная **i**, которой в коллбеке будет присвоенно значение полностью выполненного блока. Самое простое и действенное решение - это просто добавить **let**, так как **let** имеет блочную область видимости и в циклах создает новую переменную на каждой итерации.

```javascript
for (let i = 0; i < 10; i++) {
  setTimeout(function t() {
    console.log(i);
  }, i * 500);
}
// 0 1 2 3 4 5 6 7 8 9
```

Более заковырестое решение без **let** - это оставить **var** и сохранить сохранить
замыкание в модуле IIFE:

```javascript
for (var i = 0; i <= 5; i++) {
  (function () {
    var j = i; // замыкание, каждую итерацию будет создаваться новая переменная с новым значением
    // и выводиться в консоль
    setTimeout(function t() {
      console.log(j);
    }, j * 500);
  })();
}

// 0 1 2 3 4 5
```

## 4. Что такое temporal dead zone?

Легкий пример:

```javascript
{
  // bestFood’s TDZ starts here (at the beginning of this block’s local scope)
  // bestFood’s TDZ continues here
  // bestFood’s TDZ continues here
  // bestFood’s TDZ continues here
  console.log(bestFood); // returns ReferenceError because bestFood’s TDZ continues here
  // bestFood’s TDZ continues here
  // bestFood’s TDZ continues here
  let bestFood = 'Vegetable Fried Rice'; // bestFood’s TDZ ends here
  // bestFood’s TDZ does not exist here
  // bestFood’s TDZ does not exist here
  // bestFood’s TDZ does not exist here
}
```

Сложный пример:

```javascript
const EventEmitter = require('events').EventEmitter;

class CrazyEmitter extends EventEmitter {
  constructor() {
    super();
    setInterval(() => {
      this.emit(Math.random() > 0.5 ? 'resolve' : 'reject');
    }, 1000);
  }
}

class Watcher {
  firstEvent(emitter) {
    return new Promise((resolve, reject) => {
      const onResolve = () => {
        console.log('resolve');
        emitter.removeListener('reject', onReject);
        resolve();
      };

      const onReject = () => {
        console.log('reject');
        emitter.removeListener('resolve', onResolve);
        reject();
      };

      emitter.once('resolve', onResolve);
      emitter.once('reject', onReject);
    });
  }
}

const watcher = new Watcher();
const emitter = new CrazyEmitter();

function runNext() {
  watcher.firstEvent(emitter).then(runNext).catch(runNext);
}

runNext();
```

**ReferenceError** бросается когда имеет место попытка обращения к переменной раньше ее инициализации, но речь именно об инструкциях обращения и их порядке, а не о расположении обьявления переменнойы в коде.

Если говорить об инструкциях на примере выше, то движок будет обрабатывать код следующим образом (на пальцах):

1. сперва строит **LexicalEnvironment** функции с **Promise**;
2. на этапе построения создаются переменные объявленные с использованием ключевых слов **let** и **const**, но не происходит инцииализации переменных;
3. начинается выполнение инструкций;
4. если инструкция пытается обратиться к переменной объявленной с **let** или **const**, но которая еще неинициализирована, то произойдет бросок ReferenceError;
5. при встрече инструкции по созданию функции _onResolve_ создастся **LexicalEnvironment** ассоциированный с этой функцией и привязывается **LexicalEnvironment** из первого пункта, другими словами, создается замыкание в которые попали переменные _onReject_, _emitter_, _resolve_, _reject_ ...
6. обращения к _onReject_ не происходило, потому никаких исключений нет
7. к моменту когда начнет выполняться _onResolve_ переменная _onReject_ уже будет инициирована и обращение не вызовет исключения

## 5. Пример нативного модуля (через замыкание)

```javascript
var MyModules = (function Manager() {
  var modules = {};

  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }

  function get(name) {
    return modules[name];
  }

  return {
    define,
    get,
  };
})();

function funcHello() {
  function hello(who) {
    return 'Let me introduce: ' + who;
  }

  return {
    hello,
  };
}

function funcBar(bar) {
  var hungry = 'hippo';

  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }

  return {
    awesome,
  };
}

MyModules.define('bar', [], funcHello);
MyModules.define('foo', ['bar'], funcBar);

var bar = MyModules.get('bar');
var foo = MyModules.get('foo');

console.log(bar.hello('test'));
```

## 6. Какая разница между лексической ОВ (JS) и динамической (Perl и Emacs Lisp, нет в JS, похожий концепт у this)?

Лексическая область видимости означает, что область видимости определена решениями о том, где объявляются функции на стадии написания кода. Фаза разбиения на лексемы при компиляции фактически способна узнать где и как объявлены все идентификаторы, и таким образом предсказать как их будут искать во время выполнения.
Лексическая область видимости определяется временем написания кода, тогда как динамическая область видимости (и this!) определяется во время выполнения. Лексическую область видимости интересует, где функция была объявлена, а динамическую — откуда функция была вызвана.
Все ALGOL-подобные языки (Pascal, C, C#, Java и др.) используют статические области видимости.

## 7. В чем главное отличие ОВ от this?

Когда функция вызывается, создается запись активации, также известная как **контекст вызова**. Эта запись содержит информацию о том, откуда функция была вызвана (стэк вызова), как функция была вызвана, какие параметры были в неё переданы и т.д. Одним из свойств этой записи является ссылка **this**, которая будет использоваться на протяжении выполнения этой функции.
**this** — это привязка, которая создается во время вызова функции, и на что она ссылается определяется тем, где и при каких условиях функция была вызвана.

## 8. Что выведет консоль?

```javascript
function foo() {
  console.log(this.a);
}

const obj = {
  a: 2,
  foo: foo,
};

obj.foo(); // 2
```

Какое название вы бы ни выбрали для этого шаблона, в момент когда вызывается _foo()_, ей предшествует объектная ссылка на obj. Когда есть объект контекста для ссылки на функцию, правило неявной привязки говорит о том, что именно этот объект и следует использовать для привязки **this** к вызову функции.
Поскольку _obj_ является **this** для вызова _foo()_, **this.a** — синоним **obj.a**.
Только верхний/последний уровень ссылки на свойство объекта в цепочке имеет значение для точки вызова.

**!!!**

> В отличие от **lexicalEnvironment**, которое создается один раз во время создания функции, **this**(контекст) создается при каждом вызове объявленной функции.

## 9. Что такое стек вызовов (call stack) и как он работает в V8?

JavaScript — однопоточный неблокирующий язык с динамической типизацией, он использует очередь функций обратного вызова.

V8 - это движок от Google, представлен состоящим из двух основных компонентов:

- Куча (Memory Heap) — то место, где происходит выделение памяти.
- Стек вызовов (Call Stack) — то место, куда в процессе выполнения кода попадают так называемые стековые кадры.

Движок предоставляет для работы с JS цикл событий, очередь функций обратного вызова и Web API.
JavaScript — однопоточный язык программирования. Это означает, что у него один стек вызовов. Таким образом, в некий момент времени он может выполнять лишь какую-то одну задачу.
Стек вызовов — это структура данных, которая, говоря упрощённо, записывает сведения о месте в программе, где мы находимся. Если мы переходим в функцию, мы помещаем запись о ней в верхнюю часть стека. Когда мы из функции возвращаемся, мы вытаскиваем из стека самый верхний элемент и оказываемся там, откуда вызывали эту функцию. Это — всё, что умеет стек. Каждая запись в стеке вызовов называется стековым кадром. На механизме анализа стековых кадров основана информация о стеке вызовов, трассировка стека, выдаваемая при возникновении исключения. Трассировка стека представляет собой состояние стека в момент исключения. Если будет достигнут максимальный размер стека, возникнет так называемое переполнение стека. Произойти такое может довольно просто, например, при необдуманном использовании рекурсии.
Модель выполнения кода в однопоточном режиме облегчает жизнь разработчика. Ему не нужно принимать во внимание сложные схемы взаимодействия программных механизмов, вроде возможности взаимной блокировки потоков, которые возникают в многопоточных окружениях.

## 10. 4 правила определения точки вызова контекста (this)

По увеличению приоритета к концу списка:

1. Привязка по умолчанию
2. Неявная привязка
3. Явная привязка
4. Привязка **new**

**Привязка по умолчанию**
Когда включен _strict mode_, объект **window** (**global** в nodeJS) не подпадает под действие привязки по умолчанию, поэтому, в противоположность обычному режиму, **this** устанавливается в **undefined**.

```javascript
function foo() {
  console.log(this.a);
}
var a = 2;
foo(); // 2 или undefined в strict mode
```

**Неявная привязка**
Когда есть объект контекста для ссылки на функцию, правило неявной привязки говорит о том, что именно этот объект и следует использовать для привязки this к вызову функции. Поскольку _obj_ является **this** для вызова _foo()_, _this.a_ — синоним _obj.a_.

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
};

obj.foo(); // 2
```

**Явная привязка**

```javascript
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
};

foo.call(obj); // 2
```

```javascript
function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

var obj = {
  a: 2,
};

var bar = foo.bind(obj);

var b = bar(3); // 2 3
console.log(b); // 5
```

**Привязка new**
В традиционных классо-ориентированных языках, "конструкторы" — это особые методы, связанные с классами, таким образом, что когда создается экземпляр класса с помощью операции **new**, вызывается конструктор этого класса. На самом деле нет никакой связи с классо-ориентированной функциональностью у той, что предполагает использование **new** в JS. В JS конструкторы — это всего лишь функции, которые, так уж получилось, были вызваны с операцией **new** перед ними. Они ни связаны с классами, ни создают экземпляров классов. Они — даже не особые типы функций. Они — всего лишь обычные функции, которые, по своей сути, "украдены" операцией **new** при их вызове. Нет такой вещи как "функции-конструкторы", а скорее есть вызовы, конструирующие из функций.

Когда функция вызывается с указанием перед ней **new**, также известный как вызов конструктора, автоматически выполняются следующие вещи:

- Создается новенький объект (т.е. конструируется) прямо из воздуха
- Только что сконструированный объект связывается с Прототипом
- Только что сконструированный объект устанавливается как привязка **this** для этого вызова функции
- За исключением тех случаев, когда функция возвращает свой собственный альтернативный объект, вызов функции с **new** автоматически вернет только что сконструированный объект.

**new** — единственный путь, с помощью которого **this** при вызове функции может быть привязан.

```javascript
function test(a) {
  this.a = a;
}

var b = new test('test');
console.log(b.a); // 'test'
```

```javascript
'use strict';
function test(a) {
  this.a = a;
}

const obj = {};
const t = test.bind(obj);

t('v8');
console.log(t); // function test()
console.log(obj); // Object {a: "v8"}
console.log(obj.a); // 'v8'
```

**new** и **call**/**apply** не могут использоваться вместе.

## 11. Что такое прототипы и прототипное наследование (прототипирование)

Объекты в JavaScript имеют внутреннее свойство, обозначенное в спецификации как **[[Prototype]]**, которое является всего лишь ссылкой на другой объект. Почти у всех объектов при создании это свойство получает не-**null** значение.

> Cтандартное поведение **[[Get]]** и **[[Put]]** неприменимо, если используются **Proxy**!

Если стандартная операция **[[Get]]** не может найти запрашиваемое свойство в самом объекте, то она следует по ссылке **[[Prototype]]** этого объекта.

В конце каждой типичной цепочки **[[Prototype]]** находится встроенный объект **Object.prototype**. Этот объект содержит различные утилиты, используемые в JS повсеместно, поскольку все обычные (встроенные, не связанные с конкретной средой исполнения) объекты в JavaScript "происходят от" объекта **Object.prototype** (иными словами, имеют его на вершине своей цепочки **[[Prototype]]**). \***\*proto\*\*** - это тупо просто свойство, которое показывает, устанавливает и указывает на прототип текущего объекта.

```javascript
'use strict';
const obj = {
  movie: 'Interstellar',
};
const obj1 = Object.create(obj); // Object { movie: "Interstellar" }
```

В JavaScript нет абстрактных шаблонов/схем объектов, называемых "классами". В JavaScript просто есть объекты. В JavaScript копирования новых инстансов класса не происходит. Вы не создаете множественные экземпляры класса. Вы можете создать множество объектов, \*связанных ссылкой **[[Prototype]]** с общим объектом. Но по умолчанию никакого копирования не происходит, поэтому эти объекты не становятся полностью автономными и не соединенными друг с другом, напротив, они весьма связаны.

В JavaScript мы не делаем копии из одного объекта ("класса") в другой ("экземпляр"). Мы создаем ссылки между объектами.
На самом деле **new** как бы перехватывает любую обычную функцию и вызывает её так, что в результате создается объект, а также выполняется код самой функции. В JavaScript "конструктор" — это любая функция, вызванная с ключевым словом **new** перед ней.

```javascript
const obj = {
  movie: 'Interstellar',
};

const obj1 = {};

console.log(obj1.movie); // undefined  - нет наследования
```

1. \_\_proto\_\_

```javascript
const obj = {
  movie: 'Interstellar',
};

const obj1 = {};
obj1.__proto__ = obj; // подключаем наследование (ссылку на прототип)

console.log(obj1.movie); // 'Interstellar'
```

2. Object.create()

```javascript
const obj = {
  movie: 'Interstellar',
};

const obj1 = Object.create(obj); // подключаем наследование (ссылку на прототип), по сути - это: obj1.__proto__ = obj;

console.log(obj1.movie); // 'Interstellar'
```

**Object.create(..)** создает новый объект (bar), связанный с объектом, который мы указали (foo), и это дает нам всю мощь (делегирование) механизма **[[Prototype]]**, но без ненужных сложностей вроде функции **new**, выступающей в роли классов и вызовов конструктора, сбивающих с толку ссылок **.prototype** и **.constructor**, и прочих лишних вещей.

3. Object.setPrototypeOf()

```javascript
const objB = {
  movie: 'Interstellar',
};
const objB1 = {};
Object.setPrototypeOf(objB1, objB);
console.log(obj1.movie); // 'Interstellar'
```

> Обычно под "наследованием" подразумевается отношение между двумя "классами", а не между "классом" и "экземпляром".

```javascript
// пред-ES6
// выбрасывает стандартный существующий `Bar.prototype`
Bar.prototype = Object.create(Foo.prototype);

// ES6+
// изменяет существующий `Bar.prototype`
Object.setPrototypeOf(Bar.prototype, Foo.prototype);
```

По множеству причин, среди которых не последнюю роль играет терминологический прецедент, "наследование" (и "прототипное наследование") и все остальные ОО-термины не имеют смысла, учитывая то, как на самом деле работает JavaScript.
Более подходящим термином является "делегирование", поскольку эти связи являются не копиями, а делегирующими ссылками.

## 12. Что происходит "под капотом" у Object.create()

**Object.create(..)** была добавлена в ES5. Вам может понадобиться поддержка пред-ES5 окружения (например, старые версии IE), поэтому давайте рассмотрим простенький частичный полифилл для Object.create(..):

```javascript
if (!Object.create) {
  Object.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
  };
}
```

## 13. Что такое свойство функции prototype?

Особое свойство, оно работает с оператором **new**. Ссылка на объект-прототип копируется во внутреннее свойство [[Prototype]] нового объекта.

## 14. Что такое внутреннее свойство [[Prototype]]?

Это внутренняя ссылка, которая существует в одном объекте и ссылается на другой объект. Эта ссылка используется при обращении к несуществующему свойству/методу первого объекта. В таком случае ссылка **[[Prototype]]** говорит движку, что свойство/метод нужно искать в связанном объекте. В свою очередь, если поиск в этом объекте завершается неудачно, то происходит переход уже по его ссылке **[[Prototype]]** и так далее. Эта последовательность ссылок между объектами образует так называемую "цепочку прототипов".

## 15. Что такое ** proto ** ?

Это нереккомендуемое свойство назначения **[[Prototype]]** объекта объекта, от которого будет происходить наследование свойств. Лучше использовать **Object.create(obj)**, если необходимо реализовать явное наледование объекта (не конструктора, не класса , а имеено объекта);
К слову, Кайл Симпсон в своей книге _Вы не знаете JS: this и Прототипы Объектов_ прямо призывает изспользовать явное прототипное наследование без конструкторов и ****proto****, **prototype**, а с **Object.create(obj)** везде.

**** proto **** - это геттер/сеттер для **Object.prototype**.

```javascript
console.log([].__proto__); // Array[] concat(), constructor(), ..., pop(), ...

const obj1 = { test: '1' };
const obj2 = { noTest: '2' };
obj2.__proto__ = obj1;
console.log(obj2.test); //  '1' (подключенное наследование)
console.log(obj2.__proto__); // { test: '1' }
```

Также, если просто вызвать только данное свойство с объектом, то получим объект-шаблон, от которого наследуется объект, на котором вызвано свойство ****proto****

## 16. Удалит ли оператор delete в объекте свойство, которое тот наследует от другого объекта?

Нет. Важно понимать, что прототипное наследование работает только, когда мы пытаемся получить доступ к свойству объекта. **При явном присвоении или удаление свойства объекта, прототипная цепочка не задействуется!**

```javascript
const football = {
  main: 'ball',
};

const brasil = Object.create(football);
brasil.player = 'Ronaldo';
delete brasil.main;
console.log(brasil.player); //  'Ronaldo'
console.log(brasil.main); //  'ball'
```

## 17. Что такое "движок" JS?

Движок JS сам по себе не обладает внутренним чувством времени, но он становится средой исполнения для любого произвольного фрагмента JS. Планирование «событий» (выполнений фрагментов кода JS) всегда осуществляется окружающей средой.

```javascript
// `eventLoop` - массив, работающий по принципу очереди
// (первым пришел, первым вышел)
var eventLoop = [];
var event;
// продолжать "бесконечно"
while (true) {
  // отработать "квант"
  if (eventLoop.length > 0) {
    // получить следующее событие в очереди
    event = eventLoop.shift();
  }
  // выполнить следующее событие
  try {
    event();
  } catch (err) {
    reportError(err);
  }
}
```

Каждая итерация цикла называется **тиком**. В каждом тике, если в очереди ожидает событие, оно, событие, извлекается и выполняется. Этими событиями становятся ваши функции обратного вызова.
Cуть асинхронности — управление промежутком между «сейчас» и «потом». Параллелизм обозначает возможность одновременного выполнения операций. Самые распространенные средства организации параллельных вычислений — процессы и потоки (threads). Процессы и потоки выполняются независимо и могут выполняться одновременно на разных процессорах и даже на разных компьютерах, но несколько потоков могут совместно использовать общую память одного процесса. С другой стороны, цикл событий разбивает свою работу на задачи и выполняет их последовательно, что делает невозможным параллельный доступ и изменения в общей памяти. Параллелизм и последовательность не могут совместно существовать в форме взаимодействующих циклов событий в разных потоках.
Однопоточный цикл событий — одно из выражений концепции параллельного выполнения.

## 18. Что такое индемпотентность?

Идемпоте́нтность (лат. idem — тот же самый + potens — способный) — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом. Термин предложил американский математик Бенджамин Пирс (англ. Benjamin Peirce) в статьях 1870-х годов.

## 19. Известные методы http(s)-запросов?

GET, POST, PUT, PATCH, DELETE, TRACE.

## 20. В чем разница между POST, PUT и PATCH?

**PUT** меняет объект целиком, создает новый ресурс или заменяет представление
целевого ресурса, данными представленными в теле запроса. (Переписывает).

**PATCH** используется для частичного изменения ресурса. (Смерживает).

**POST**:
Разница между **PUT** и **POST** - это вопрос семантики. Коль скоро для операций используются разные глаголы, то и смысл у них должен быть разным.
Представьте, что ваш сервис оперирует понятиями блокнот (notebook) и запись (post). Один блокнот может содержать множество записей.
Для добавления новой записи в блокнот c идентификатором id вы будете использовать метод **POST** с URL mydomain/notebooks/id/. Ваш сервис, ориентируясь на метод **POST**, сам присвоит нужный идентификатор записи, добавит ее в блокнот и вернет вам URL созданной записи (для доступа к записи по **GET** или для удаления по **DELETE**). При этом хорошо бы вернуть клиенту URL созданной записи.
Допустим, запись с идентификатором post-id уже создана и доступна по URL mydomain/notebooks/id/posts/post-id. Но клиент (владелец записи) исправил в ней ошибку и хочет перезаписать ее. Для этого он использует метод **PUT** с URL mydomain/notebooks/id/posts/post-id и передает обновленную запись в теле запроса. Ваш сервис, ориентируясь на метод PUT удаляет старую запись и записывает новую, при этом она доступна по тому же URL.
Конечно, никто не мешает вам всегда использовать метод **POST** (например HTML4 позволял использовать только методы GET и POST). Но все же стоит придерживаться рекомендаций в целях единообразной трактовки методов всеми разработчиками.
UPD: Рекомендуется использоваться метод **POST** для создания подчиненного ресурса (дочернего по отношению к другому ресурсу; пример блокнота и записи как раз очень подходит).

## 21. Что такое SOLID?

Роберт Мартин, для того, чтобы помочь всем желающим разрабатывать качественные ОО-приложения, разработал пять принципов объектно-ориентированного программирования и проектирования, говоря о которых, с подачи Майкла Фэзерса, используют акроним SOLID.

Вот как расшифровывается акроним SOLID:

S: Single Responsibility Principle (Принцип единственной ответственности).
(Класс должен быть ответственен лишь за что-то одно.)

O: Open-Closed Principle (Принцип открытости-закрытости).
(Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.)

L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
(Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. )

I: Interface Segregation Principle (Принцип разделения интерфейса).
(Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента(класса, компонента). Клиенты не должны зависеть от интерфейсов, которые они не используют.)

D: Dependency Inversion Principle (Принцип инверсии зависимостей).
(Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.)

## 22. Как происходит процесс рендера в браузере?

Объектная модель документа (DOM) создаётся в тот момент, когда браузер парсит HTML. Этот HTML может запрашивать JavaScript, который может модифицировать DOM. HTML может запросить стили, которые участвуют в создании CSS Object Model. Движок браузера комбинирует эти две объектные модели, чтобы создать дерево рендера (**render tree**). Компоновка (**layout**) определяет размеры и позицию каждого элемента на странице. Как только компоновка определена - пиксели отрисовываются на экране.

Загрузка веб-страницы или приложения начинается с запроса HTML. Сервер возвращает HTTP-ответ, состоящий из заголовков (**headers**) и тела запроса. Именно в теле запроса содержится HTML-документ. Браузер начинает парсить загружаемый HTML, преобразуя полученные байты документа в DOM-дерево. Браузер создаёт новый запрос каждый раз, когда он находит ссылки на внешние ресурсы, будь то файлы стилей, скриптов или ссылки на изображения. Некоторые запросы являются блокирующими. Это означает, что пока такие запросы выполняются - другие запросы приостанавливаются. Браузер продолжает парсить HTML и создавать DOM до тех пор, пока запрос на получение HTML не подходит к концу. После завершения парсинга DOM, браузер конструирует CSS модель. Как только эти модели сформированы, браузер строит дерево рендера (**render tree**), в котором вычисляет стили для каждого видимого элемента страницы. После формирования дерева происходит компоновка (**layout**), которая определяет положение и размеры элементов этого дерева. Как только этап завершён - страница рендерится. Или "отрисовывается" (**paint**) на экране.

**DOM**
Построение DOM инкрементально. Ответ в виде HTML превращается в токены, которые превращаются в узлы (nodes), которые формируют DOM дерево. Простейший узел начинается с startTag-токена и заканчивается токеном endTag. Узлы содержат всю необходимую информацию об HTML-элементе, соответствующем этому узлу. Узлы (nodes) связаны с Render Tree с помощью иерархии токенов: если какой-то набор startTag и endTag-токенов появляется между уже существующим набором токенов, мы получаем узел (node) внутри узла (node), то есть получаем иерархию дерева DOM.
Чем больше количество узлов (node) имеет приложение, тем дольше происходит формирование DOM tree, а значит дольше происходит обработка критических этапов рендеринга.

**CSSOM**
DOM несёт в себе всё содержимое страницы. CSSOM содержит все стили страницы, то есть данные о том, как стилизовать DOM. CSSOM похож на DOM, но всё же отличается. Если формирование DOM инкрементально, CSSOM - нет. CSS блокирует рендер: браузер блокирует рендеринг страницы до тех пор, пока не получит и не обработает все CSS-правила. CSS блокирует рендеринг, потому что правила могут быть перезаписаны, а значит, необходимо дождаться построения CSSOM, чтобы убедиться в отсутствии дополнительных переопределений.

У CSS имеются свои правила валидации токенов. Помните, что C в CSS означает "Cascade". CSS-правила ниспадают каскадом. Иными словами, когда парсер преобразует токены в узлы (nodes), вложенные узлы наследуют стили от родительских. Инкрементальная обработка недоступна для CSS, потому что набор следующих правил может перезаписать предыдущие. Объектная модель CSS (CSSOM) строится по мере парсинга CSS, но она не может быть использована для построения дерева рендера (render tree), потому что может оказаться так, что следующий набор правил может сделать какой-либо из узлов дерева невидимым на экране. Это может привести к лишнему вызову компоновки и перерасчёта стилей.

Говоря о производительности селекторов (selector), наименее специфичные селекторы срабатывают быстрее. Например, .foo {} сработает быстрее .bar .foo {}. В первом случае, условно, понадобится одна операция, чтобы найти элемент .foo, во втором случае, сначала будут найдены все .foo, а потом браузер пройдёт вверх по дереву в поисках родительского элемента .bar. Более специфичные селекторы требуют от браузера большего количества работы, но эти проблемы, вероятно, не стоят их оптимизации.

Если вы измерите время, требуемое на парсинг CSS, вы будете удивлены тем, как быстро работают браузеры. Более специфичные правила более затратны, потому что требуют обхода большего числа узлов в DOM дереве, но эта дороговизна обходится довольно дёшево, особенно в сравнении с другими узкими местами производительности. Сначала измеряйте. Потом оптимизируйте, если это действительно необходимо. Вероятно, специфичность селекторов не то, что действительно затормаживает ваше приложение. Когда дело доходит до оптимизации CSS, улучшение производительность селекторов ускоряет рендеринг лишь на микросекунды.

**Render tree**
Дерево рендера охватывает сразу и содержимое страницы, и стили: это место, где DOM и CSSOM деревья комбинируются в одно дерево. Для построения дерева рендера браузер проверяет каждый узел (node) DOM, начиная от корневого (root) и определяет, какие CSS-правила нужно присоединить к этому узлу.
Дерево рендера охватывает только видимое содержимое. Например, секция head (в основном) не содержит никакой видимой информации, а потому может не включаться в дерево. Кроме того, если у какого-то узла стоит свойство display: none, оно так же не включается в дерево (как и потомки этого узла).

**Layout**
В тот момент, когда дерево рендера (**render tree**) построено, становится возможным этап компоновки (**layout**). Компоновка зависит от размеров экрана. Этот этап определяет, где и как на странице будут спозиционированы элементы и каковы связи между элементами.
Метатэг **viewport**, который вы можете указать в **head** страницы, определяет ширину видимой области и влияет на компоновку. Без этого тэга браузеры используют ширину "по умолчанию", которая обычно составляет 960px. В браузерах, открывающихся по умолчанию в полноэкранном режиме, например, в браузере телефона, установка тега **<meta name="viewport" content="width=device-width">** установит ширину видимой области в 100% от ширины экрана устройства, вместо того, чтобы использовать ширину по умолчанию. Эта ширина (device-width) изменяется каждый раз, когда пользователь поворачивает телефон. Это приводит к запуску этапа компоновки. Равно как и при изменении размеров окна в обычном браузере.
На производительность компоновки (layout) непосредственно влияет DOM - чем больше узлов (nodes) в вашем документе, тем больше времени понадобится на перерасчёт позиций и размеров всех элементов. Компоновка может стать узким местом, ведущим к зависаниям, особенно если выполняется одновременно со скроллом или другой анимацией. И хотя задержка 20мс при загрузке или переориентации экрана может быть приемлемой, это всё равно может привести к подвисаниям при анимации и скролле. Каждый раз, когда дерево рендера (render tree) модифицируется, например, из-за добавления узла (node), его модификации или при изменении стилей box-модели, запускается компоновка.
Для уменьшения частоты и продолжительности этого этапа, группируйте обновления экрана и избегайте анимации свойств, связанных с box-моделью элементов.

**Paint**
Последний этап в нашем списке - отрисовка (paint) пикселей на экране. Когда дерево рендера (render tree) создано, компоновка (layout) произошла, пиксели могут быть отрисованы. При первичной загрузке документа (onload) весь экран будет отрисован. После этого будут перерисовываться только необходимые к обновлению части экрана, так как браузер старается оптимизировать процесс отрисовки, избегая ненужной работы. Так, если у вас в документе есть два элемента, перерисовываться будет только тот, который вы изменили. Время отрисовки зависит от того, какой тип обновления применился к дереву рендера (render tree). И хотя отрисовка - это очень быстрый процесс, и он, вероятно, слабо влияет на производительность, очень важно помнить, что оба этапа - компоновка (layout) и отрисовка (paint) должны работать сообща и укладываться в частоту обновления кадров. Каждое CSS-свойство, применяемое к любому узлу (node) увеличивает время отрисовки, но полное удаление стиля, способное сэкономить вам 0.001мс, вряд ли даст вам желаемый результат, но зато с лёгкостью ухудшит пользовательский опыт. Помните - сначала нужно измерять, а потом оптимизировать только необходимое!

## 23. Более подробный разбор ключевых этапов работы браузера

_Конспект статьи_ [Принципы работы современных веб-браузеров](https://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/)

**Модуль отображения**
модуль отображения отвечает за вывод запрошенного содержания на экране браузера. В Firefox применяется Gecko – собственная разработка Mozilla, а в Safari и Chrome используется WebKit. WebKit представляет собой модуль отображения с открытым исходным кодом, который был изначально разработан для платформы Linux и адаптирован компанией Apple для Mac OS и Windows. Модуль отображения получает содержание запрошенного документа по протоколу сетевого уровня, обычно фрагментами по **8 КБ**.
Модуль отображения выполняет синтаксический анализ HTML-документа и переводит теги в узлы DOM в дереве содержания (создание DOM-дерева). Информация о стилях извлекается как из внешних CSS-файлов, так и из элементов style. Эта информация и инструкции по отображению в HTML-файле используются для создания еще одного дерева – дерева отображения.

То же самое, но чуть подробнее:

1. Модуль отображения выполняет синтаксический анализ HTML-документа и переводит теги в узлы DOM в дереве содержания. Информация о стилях извлекается как из внешних CSS-файлов, так и из элементов style. (DOM tree + CSSOM tree = Render tree)
2. Прямоугольники с визуальными атрибутами, такими как цвет и размер. Прямоугольники располагаются в том порядке, в каком они должны быть выведены на экран.
3. После создания дерева отображения начинается компоновка элементов, в ходе которой каждому узлу присваиваются координаты точки на экране, где он должен появиться (Layout).
4. Затем выполняется отрисовка, при которой узлы дерева отображения последовательно отрисовываются с помощью исполнительной части пользовательского интерфейса (Paint).

Важно понимать, что это последовательный процесс. Для удобства пользователя модуль отображения старается вывести содержание на экран как можно скорее, поэтому создание дерева отображения и компоновка могут начаться еще до завершения синтаксического анализа кода HTML. Одни части документа анализируются и выводятся на экран, в то время как другие только передаются по сети.

В Gecko дерево визуально отформатированных элементов называется деревом фреймов (frame tree), в котором каждый элемент является фреймом. В WebKit используется дерево отображения (render tree), состоящие из объектов отображения (render objects). Размещение элементов в WebKit называется компоновкой, или версткой (layout), а в Gecko – обтеканием (reflow).

##### Потоки модуля отображения

Модуль отображения работает с одним потоком: в нем выполняется почти все, кроме сетевых операций. В Firefox и Safari это основной поток браузера, в Chrome – основной процесс вкладки.
Сетевые операции могут выполняться в нескольких параллельных потоках. Количество параллельных соединений ограничено и обычно составляет от 2 до 6 (например, в Firefox 3 их используется 6).

##### Лексический анализ

Лексический анализ представляет собой разделение информации на токены, или лексемы. Токены образуют словарь того или иного языка и являются конструктивными элементами для создания документов. В естественном языке токенами бы были все слова, которые можно найти в словарях.

Анализ документа обычно выполняется двумя компонентами: лексическим анализатором, разбирающим входную последовательность символов на действительные токены, и синтаксическим анализатором, анализирующим структуру документа согласно синтаксическим правилам данного языка и формирующим синтаксическое дерево. Анализатор игнорирует неинформативные символы, такие как пробелы и переносы строк.

Результатом работы алгоритма является токен HTML. Алгоритм выражен в виде автомата с конечным числом состояний. В каждом состоянии обрабатывается один или несколько символов входной последовательности, на основе которых определяется следующее состояние. Оно зависит от этапа лексического анализа и этапа формирования дерева, то есть обработка одного и того же символа может привести к разным результатам (разным состояниям) в зависимости от текущего состояния.

**Синтаксический анализ.**
Результатом синтаксического анализа, как правило, является дерево узлов, представляющих структуру документа. Оно называется деревом синтаксического анализа, или просто синтаксическим деревом. Синтаксический анализ работает на основе определенных правил, которые определяются языком (форматом) документа. Для каждого формата существуют грамматические правила, состоящие из словаря и синтаксиса. Они образуют т. н. бесконтекстную грамматику. Естественные языки не подчиняются правилам бесконтекстной грамматики, поэтому стандартные техники синтаксического анализа для них не годятся.

Синтаксическое дерево не всегда бывает окончательным результатом. Синтаксический анализ часто используется в процессе перевода входного документа в нужный формат. Примером может служить компиляция. Компилятор, который переводит исходный код в машинный, сначала разбирает его и формирует синтаксическое дерево, а лишь потом создает на основе этого дерева документ с машинным кодом.

Синтаксические анализаторы бывают двух типов: нисходящие и восходящие. Первые выполняют анализ сверху вниз, а вторые – снизу вверх. Нисходящие анализаторы разбирают структуру верхнего уровня и ищут соответствия синтаксическим правилам. Восходящие анализаторы сначала обрабатывают входную последовательность символов и постепенно выявляют в ней синтаксические правила, начиная с правил нижнего и заканчивая правилами верхнего уровня.
В WebKit используется два известных генератора: Flex для создания лексического и Bison для создания синтаксического анализатора (они также встречаются под названиями Lex и Yacc). Во Flex загружается файл с определениями токенов в регулярных выражениях, а в Bison – синтаксические правила языка в формате BNF.

HTML невозможно определить с помощью бесконтекстной грамматики, с которой работают синтаксические анализаторы.
Существует формальный стандарт определения HTML – формат DTD (Document Type Definition), однако его грамматика не является бесконтекстной.
Разница в том, что в HTML используется менее строгий подход: если пропущены некоторые теги (например, открывающие или закрывающие), они подставляются автоматически. Такой "мягкий" синтаксис отличается от строгого синтаксиса XML. Грамматика HTML не является бесконтекстной, поэтому его анализ нельзя выполнить ни с помощью стандартных анализаторов, ни с помощью анализаторов XML.

Алгоритм синтаксического анализа состоит из двух этапов: лексического анализа и построения дерева.

При создании синтаксического анализатора формируется объект Document. На этапе построения дерево DOM, в корне которого находится этот объект, изменяется и к нему добавляются новые элементы. Каждый узел, генерируемый лексическим анализатором, обрабатывается конструктором деревьев. Для каждого токена создается свой элемент DOM, определенный спецификацией. Элементы добавляются не только в дерево DOM, но и в стек открытых элементов, который служит для исправления неправильно вложенных или незакрытых тегов. Алгоритм также выражается в виде автомата с конечным числом состояний, которые называются "способами включения" (insertion mode).

CSS
В отличие от HTML, в CSS используется бесконтекстная грамматика, поэтому для анализа подходят стандартные средства,
ruleset
: selector [ ',' S* selector ]_
'{' S_ declaration [ ';' S* declaration ]_ '}' S_
;
selector
: simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?
;
simple_selector
: element_name [ HASH | class | attrib | pseudo ]_
| [ HASH | class | attrib | pseudo ]+
;
class
: '.' IDENT
;
element_name
: IDENT | '_'
;
attrib
: '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
[ IDENT | STRING ] S* ] ']'
;
pseudo
: ':' [ IDENT | FUNCTION S* [IDENT S*] ')' ]
;

В WebKit для автоматического создания синтаксических анализаторов CSS используются генераторы Flex и Bison. Как уже говорилось, Bison служит для создания восходящих анализаторов, при работе которых входная последовательность символов сдвигается вправо. В Firefox используется нисходящий анализатор, разработанный организацией Mozilla. В обоих случаях файл CSS разбирается на объекты StyleSheet, содержащие правила CSS. Объект правил CSS содержит селектор и объявление, а также другие объекты, характерные для грамматики CSS.

##### Скрипты

Веб-документы придерживаются синхронной модели. Предполагается, что скрипты будут анализироваться и исполняться сразу же, как только анализатор обнаружит тег <script>. Синтаксический анализ документа откладывается до завершения выполнения скрипта. Если речь идет о внешнем скрипте, сначала необходимо запросить сетевые ресурсы. Это также делается синхронно, а анализ откладывается до получения ресурсов. Такая модель использовалась много лет и даже занесена в спецификации HTML 4 и 5. Разработчик мог пометить скрипт тегом defer, чтобы синтаксический анализ документа можно было выполнять до завершения выполнения скрипта. В HTML5 появилась возможность пометить скрипт как асинхронный (asynchronous), чтобы он анализировался и выполнялся в другом потоке.

##### Ориентировочный синтаксический анализ

Этот механизм оптимизации используется и в WebKit, и в Firefox. При выполнении скриптов остальные части документа анализируются в другом потоке, чтобы оценить необходимые ресурсы и загрузить их из сети. Таким образом, ресурсы загружаются в параллельных потоках, что повышает общую скорость обработки. Обратите внимание: ориентировочный анализатор не изменяет дерево DOM (это работа основного анализатора), а лишь обрабатывает ссылки на внешние ресурсы, такие как внешние скрипты, таблицы стилей и картинки.

##### Дерево отображения

В Firefox элемент дерева отображения называется "фреймом" (frame). В WebKit используется термин "объект отображения" (render object).
Каждый объект отображения располагает данными об отрисовке самого себя и своих дочерних элементов.
Класс **RenderObject** – основной класс объектов отображения в WebKit.

В Firefox визуальное представление регистрируется как слушатель обновлений DOM. Создание фреймов делегируется конструктору FrameConstructor, который определяет стили и создает фрейм.

В результате обработки тегов **html** и **body** создается корневой объект дерева отображения. В спецификации CSS он называется контейнером – блоком верхнего уровня, в котором содержатся все остальные блоки. Его размеры формируют область просмотра, то есть часть окна браузера, в которой будет показано содержание. В Firefox она называется ViewPortFrame, а в WebKit – RenderView. Это объект отображения, на который указывает документ. Остальное дерево строится посредством добавления в него узлов DOM.

##### Вычисление стилей

Чтобы построить дерево отображения, необходимо рассчитать визуальные свойства каждого объекта. Для этого вычисляются свойства стиля каждого элемента. После синтаксического анализа таблицы стилей каждое правило добавляется в одну или в несколько хэш-карт в зависимости от селектора. Существуют карты, организованные по идентификатору, названию класса или тега, а также общие карты для всех остальных случаев. Если селектором является идентификатор, правило добавляется в карту идентификаторов, если класс, то в карту классов и т. д.
Такая классификация упрощает поиск подходящих правил. Нам не приходится проверять все объявления: достаточно извлечь из карты подходящие правила. Такая классификации позволяет сразу отбросить более 95% правил, что ускоряет и упрощает процесс сопоставления.

В спецификации CSS2 указан следующий порядок приоритета (по возрастанию).

- самый низкий Объявления браузера
- Обычные объявления пользователя
- Обычные объявления автора
- Важные объявления автора
- самый высокий Важные объявления пользователя

Объявления с одинаковым приоритетом сортируются по степени специфичности, а затем по порядку, в котором были определены. Визуальные атрибуты HTML переводятся в соответствующие объявления CSS и обрабатываются как правила автора с низким приоритетом.

Модель окна в CSS описывает прямоугольные окна, которые создаются для элементов, содержащихся в дереве документа, и компонуются согласно модели визуального форматирования.
В каждом окне есть область для содержания (текста, картинок и т. д.) и место для необязательных отступов, рамок и полей.

Окна делятся на стеки (стековые контексты). В каждом стеке сначала отрисовываются элементы на заднем плане, а затем на переднем (расположенные ближе к пользователю). Если они перекрываются, элементы на заднем плане не будут видны.
Порядок стеков определяется свойством z-index. Окна со свойством z-index формируют локальный стек, а область просмотра представляет собой внешний стек.

##### Компоновка (Layout)

Когда только что созданный объект отображения включается в дерево, он не имеет ни размера, ни положения. Расчет этих значений называется компоновкой (layout или reflow).

В HTML используется поточная модель компоновки, то есть в большинстве случае геометрические данные можно рассчитать за один проход. Элементы, встречающиеся в потоке позднее, не влияют на геометрию уже обработанных элементов, поэтому компоновку можно выполнять слева направо и сверху вниз. Существуют исключения: например, для компоновки таблиц HTML может потребоваться более одного цикла. Система координат рассчитывается на основе корневого фрейма. Используются верхняя и левая координаты.

Система "грязных битов". Используется два флага: dirty и children are dirty. Флаг children are dirty означает, что перекомпоновка требуется не самому объекту отображения, а одному или нескольким из его дочерних объектов.
Если компоновка выполняется для всего дерева отображения, она называется глобальной. Ее могут вызывать перечисленные ниже события.

1. Глобальное изменение стиля, который используется во всех объектах отображения, например изменение шрифта.
2. Изменение размеров экрана.

Синхронная и асинхронная компоновка
Инкрементная компоновка выполняется асинхронно. В Firefox команды инкрементной компоновки помещаются в очередь, а затем планировщик вызывает их все вместе. В WebKit выполнение инкрементной компоновки также откладывается, чтобы обработать целое дерево за один цикл и перекомпоновать все "грязные" объекты отображения.
Скрипты, запрашивающие данные о стилях, такие как offsetHeight, могут привести к синхронному выполнению инкрементной компоновки.
Глобальная компоновка обычно выполняется синхронно.
Иногда компоновка выполняется в обратном вызове после исходной компоновки, потому что меняются значения некоторых атрибутов, таких как положение прокрутки.

Если в процессе компоновки объект отображения обнаруживает, что необходим перенос строки, компоновка останавливается, а родительскому элементу передается запрос на перенос строки. Родительский элемент создает дополнительные объекты отображения и выполняет их компоновку.

##### Отрисовка

На этапе отрисовки для каждого объекта отображения по очереди вызывается метод **paint** и их содержание выводится на экран. Для отрисовки используется компонент инфраструктуры пользовательского интерфейса.

Глобальная и инкрементная отрисовка
При глобальной отрисовке все дерево отрисовывается целиком, а при инкрементной – только отдельные объекты отображения, не влияющие на остальные части дерева. Измененный объект отображения помечает свой прямоугольник как недействительный. Операционная система расценивает его как "грязную" область и вызывает событие **paint**. Области при этом объединяются, чтобы отрисовку можно было выполнить сразу для всех. В браузере Chrome отрисовка выполняется несколько сложнее, так как объект отображения находится вне главного процесса: Chrome в некоторой степени имитирует поведение операционной системы. Компонент визуального представления прослушивает эти события и делегирует сообщение корневому объекту отображения. Все объекты дерева по очереди проверяются, пока не будет найден нужный. Затем выполняется отрисовка его самого и, как правило, его дочерних элементов.

Порядок отрисовки играет важную роль, так как стеки отрисовываются задом наперед. Порядок добавления блочных объектов в стек таков:

1. Цвет фона
2. Фоновое изображение
3. Рамка
4. Дочерние объекты
5. Внешние границы

Хранилище прямоугольников в WebKit. Перед повторной отрисовкой старый прямоугольник сохраняется в WebKit как растровое изображение, а затем отрисовываются только различия между старым и новым прямоугольником.

##### Цикл событий

Основной поток браузера представляет собой цикл событий – бесконечный цикл, который поддерживает рабочие процессы. Он ожидает отправки событий (таких как layout и paint), чтобы их обработать. Так выглядит код Firefox для основного цикла событий:

while (!mExiting)
NS_ProcessNextEvent(thread);

## 24. Что такон CORS (Cross Origin Resource Sharing)?

Если браузер запрашивает тег из источника, который отличается от получателя по схеме, в полностью определенному имени хоста или порту, то это и есть запрос между различными источниками (cross-origin request).

Источник состоит из 3 частей:

1. схема (http or https)
2. имя хоста (google.com, somesite.org...)
3. порт (:3000, :3010, :8000, ...)

> пример источника: https://www.test.com:3000

Политика одинакового источника предотвращает cross-origin атаки, блокируя доступ для прочтения загружаемых ресурсов из другого источника.
Несмотря на то, что браузер по умолчанию может разрешить определенный тип запросов между различными источниками, это не означает, что данный запрос будет принят сервером.

CORS — это механизм, который дает возможность контролировать доступ к тегам на веб странице по сети. Механизм классифицируется на три разные категории доступа тегов:

1. Запись из разных источников (ссылки, переадресации и отправка форм. С активным CORS в вашем браузере все эти операции разрешены.)
2. Вставка из разных источников (теги, загружаемые через **script**, **link**, **img**, **video**, **audio**, **object**, **embed**, **iframe** и т.п. Все они разрешены по умолчанию. <iframe> выделяется на их фоне, так как он используется для загрузки другой страницы внутри фрейма. Его обрамление в зависимости от источника может регулироваться посредством использования заголовка X-Frame-options.
3. Считывание из разных источников (теги, загружаемые через вызовы AJAX/ fetch. Все они по умолчанию заблокированы вашим браузером.)

Предварительные запросы выполняются перед запросами, которые CORS считает сложными. Признаки, свидетельствующие о сложности запроса:

- Запрос использует методы отличные от **GET**, **POST**, или **HEAD**
- Запрос включает заголовки отличные от **Accept**, **Accept-Language** или **Content-Language**
- Запрос имеет значение заголовка **Content-Type** отличное от **application/x-www-form-urlencoded**, **multipart/form-data**, или **text/plain**

Чтобы смягчить политику CORS нашего сайта мы можем присвоить опцию **Access-Control-Allow-Origin** для нашего действия для опеределенного ресурса.
