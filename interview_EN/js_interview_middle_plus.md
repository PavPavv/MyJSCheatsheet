# Middle+/Senior topics

## Deep theory (from the "Advanced JavaScript Unleashed" book by Yousaf Khan)

### ECMASCript language, JIT Compiler, JavaScript Engine

In the case of JavaScript, the JavaScript engines do not output an executable file, which is one of the reasons it is thought of as an interpreted language.
However, the JavaScript code is compiled into an intermediary form known as byte code, which is then executed by the virtual machine. The virtual machine interprets byte code, but modern JavaScript engines don’t just interpret the byte code; they include what’s known as the “Just-in-time (JIT) compiler” to compile the byte code into native machine code, which is executed at a faster speed than the byte code.

Just-in-time (JIT) compilation is a technique used by many modern JavaScript engines to increase
the execution speed of the JavaScript code. Unlike traditional compilers, which compile the code ahead of time, the JIT compiler compiles the code at runtime while the code is being executed. It is safe to say that it is both - compiled as well as an interpreted language.

To execute JavaScript code, we need another software known as a JavaScript engine. This engine contains all the necessary components to transform the code into something the machine can execute.

Source TS Code -> TSC -> Source code -> Parser -> AST -> Interpreter -> Bytecode -> Compiler -> Machine Code

The engine itself doesn’t have the capability to download the code. The browser does it and the  passes it to the engine, which can then begin transforming it and eventually execute it.

After downloading the source code, the next step is to transform it into tokens.

Once the tokens have been generated, the parser uses them to generate an Abstract Syntax Tree.

The Bytecode Generator uses the AST produced by the parser to generate the bytecode. This generated bytecode is taken by the Bytecode Interpreter, which then interprets it.

While the bytecode is executed, the JavaScript engine collects information about the code being executed. The engine then uses this information to optimize the code further.

The need for falling back to the bytecode arises from the fact that JavaScript is a dynamically typed language. The optimized native machine code is generated using the information collected during the execution of the JavaScript code. The native machine code requires certain checks to ensure that the assumptions made during the generation of the native machine code are not violated. If the checks fail, the JavaScript engine has to execute the bytecode instead of the native machine code.
This process is called deoptimization.

Whenever any JavaScript code is executed, it is executed inside an environment. By “environment”, I mean everything that is accessible by the code that aids in its execution. For example, the value of this , variables in the current scope, function arguments, etc. This environment is known as the “Execution Context”. Every time any JavaScript code is executed, an execution context is created before its execution.

• Global execution context
• Function execution context
• eval()

Execution context phases: creation phase(1) and execution phase(2).

(1)During this phase, the variable declarations and references to functions are saved as key-value pairs inside the execution context. The value of this and a reference to the outer environment are also set during this phase. In the case of a global context, there is no outer environment, so reference to the outer environment
is set to null , but in the case of a function context, the value of this depends on how the function is called, so the value of this is set appropriately.

### Lexical and Variable environments

During the creation phase, the following two components are created:

- Lexical environment
- Variable environment

A call stack is a structure that is used internally by the JavaScript engine to keep track of the piece of code that is currently executing. The call stack is simply a stack²² data structure that aids in the execution of the JavaScript code by keeping track of currently executing code. You can also think of a call stack in JavaScript as a collection of execution contexts. Before executing any JavaScript code, a global execution context is created and pushed on the call stack. After pushing the global execution context on the call stack, any function calls encountered during the execution of the code will lead to more entries in the call stack. For every function call, a new entry is added to the call stack before that function starts executing, and as soon as the function execution ends, that entry is popped off the stack.

### Infinite loop (stack overflow)

Remember what happens when a function is called? A new entry is added to the call stack. In the case of the above function that just calls itself and never finishes executing, we are just adding the new entries in the call stack without ever removing any entries. This is infinite recursion, and this leads to an error known as stack overflow. This error is thrown when the call stack gets filled up to its limit and can no longer hold more entries.

The official ECMAScript specification doesn’t state anything about how JavaScript engines should allocate memory for different types of values or how they should free up memory once it is no longer needed by the program. As a result, different JavaScript implementations are free to choose how they want to handle memory management in JavaScript.

JavaScript values in V8 are represented as objects and allocated on the V8 heap, no matter if they are objects, arrays, numbers, or strings. This allows us to represent any value as a pointer to an object.

### Hoisting

In JavaScript, variables and functions can be accessed before their actual declaration. The term “hoisting” is mostly associated with function declarations and variables declared with the “var” keyword. 

The JavaScript engine scans the code before executing it, allowing it to detect some errors before any code is executed. This also enables the engine to handle variable declarations by registering the variables declared in the current scope. Before any scope starts, all the variables declared in that scope are registered for that scope. In other words, all the variables declared in a scope are reserved for that scope before the code in that scope is executed. This preprocessing of the code before its
execution is what enables hoisting. Function declarations, just like variables declared using the “var” keyword, are also hoisted.

According to the standard rules, the function declarations inside blocks are hoisted to the top of the block, converted into a function expression, and assigned to a variable declared with the let keyword. The function hoisted inside the block is limited to the containing block and cannot be accessed by code outside the block containing the function.

Like function declarations, class declarations are also hoisted, but they are hoisted differently compared to the function declarations.

#### Temporal Dead Zone (TDZ)

Temporal Dead Zone (TDZ) refers to the time during which the block-scoped variables ( let , const ) or class declarations cannot be accessed. The time starts from the start of the scope till the declaration is executed. TDZ is the reason class declarations cannot be accessed before their declaration is executed during
the step-by-step execution of the code. As TDZ also applies to the let and const , are the variables declared using let or constants using const also hoisted? Yes, they are also hoisted, but, like the class declarations, they are hoisted differently because of the TDZ. It is a common misconception that block-scoped variables and constants are not hoisted, but as we discussed above, they are hoisted; it’s just that their hoisting is different as compared to the hoisting of variables declared using the var keyword.

JavaScript engines don’t move the hoisted declarations to the top of the file. Instead, they simply process the declarations before the step-by-step execution of the code. In the case of var variables, they are assigned the value of undefined until their declaration is executed. In the case of block-scoped variables, they are marked as “uninitialized”.

### Scope

In JavaScript, the scope of different identifiers (variables, functions, etc.) is determined at compile time. Before the step-by-step execution of the JavaScript code starts, JavaScript engines determine the scopes of different declarations in the code.

This type of scope, which is determined at compile time by analyzing the code structure, is known as lexical scope. JavaScript is not the only language that has a lexical scope. Other languages, like Java, also have a lexical scope. Lexical scope is also known as “static” scope. An alternative type of scope is Dynamic scope.

Variables created using the var keyword or function declarations declared in the global scope are added as properties on the window object. If the todoList was declared with let or const , it wouldn’t have been added as a property on the window object, but it would still be a global variable.

Whenever there is an assignment to an undeclared variable, JavaScript will declare that undeclared variable as a global variable.

The id of the h1 element above gets added to the global scope as a variable. We can access the h1 element using the mainHeading as a variable in JavaScript code. This feature is referred to as Named access on the Window object.

```javascript
function paramScope(arr = ["initial array"], buff = () => arr) {
  var arr = [1, 2, 3];
  console.log(arr); // [1, 2, 3]
  console.log(buff()); // ["initial array"]
}
paramScope();
```

The answer is that the arr parameter and the arr variable inside the function are two different variables that exist in two different scopes. The arr inside the function shadows the arr parameter, but calling the buff function returns the parameter arr . If the parameter and the local arr were the same variable, the buff function would return [1, 2, 3] instead of the default value of the arr parameter. Remove the var keyword inside the function to show the different output:

```javascript
function paramScope(arr = ["initial array"], buff = () => arr) {
  arr = [1, 2, 3];
  console.log(arr); // [1, 2, 3]
  console.log(buff()); // [1, 2, 3]
}
paramScope();
```

### Coercion

Coercion in JavaScript is the conversion of one type of value into another type of value.
If the hint argument is “number”, then the OrdinaryToPrimitive abstract operation first invokes the valueOf method and then the toString method, if needed.

```javascript
0 == false  // true

"" == false // true

0 == [] // -> 0 == "" -> 0 == 0 -> true

[123] == 123  // "123" == 123 -> 123 == 123 -> true

[1] < [2] // true

[] == ![] // -> [] == false -> [] == 0 -> "" == 0 -> 0 == 0 -> true

!!"true" == !!"false" // true

[1, 2, 3] + [4, 5, 6] // "1,2,34,5,6"

[undefined] == 0  // true

[[]] == ''  // true

[] + {} // [object Object]
```

### Closures

The closure is a combination of the following two things:
• A Function
• A reference to the environment/scope in which that function is created

Every time a javascript function is created, a closure is formed, which allows that function to access the scope chain that was in effect when that function was defined. Each time a function is created, javascript saves the reference to the surrounding environment of the function in the internal "[[Environment]]" slot on the function object. When that function is called, a new environment is created for that function call, and javascript saves the value of [[Environment]] slot on the function in the [[OuterEnv]] slot of the environment object.
It is a common misconception among beginners that closures are only formed when any function returns a nested function. But that is not the case.
Every time a function is created in JavaScript, it forms a closure over the environment in which that function was created. Forming a closure is a fancy way of saying that when a function is created, it saves a reference to the environment in which it was created.

## Data structures

Linear data structures are simple in direction. A linked list is a list of nodes (each containing their own data) that are linked from one node to the next (and to the previous, for a doubly linked list). A stack builds upward like a tower of data. Each node stacking atop another, and shortens in a last in first out (LIFO) manner. A queue is a line of nodes that elongate from the end of the line and shortens in a first in first out (FIFO) mechanism.

Binary data structures are like a fork in a road of data. The nodes build like the branches of a tree or a heap of rocks.

## Binary Search Tree

Compared to a normal tree, BST has the following properties:

- every left child has a smaller value than its parent
- every right child has a larger value than its parent
- every node can contain from 0 to 2 children

```javascript
const binarySearchTree = {
  value: 4,

  left: {
    value: 2,
    left: {
      value: 1,
    },
    right: {
      value: 3,
    },
  },

  right: {
    value: 5,
    right: {
      value: 6,
    },
  },
};

function sumTree(tree) {
  let count = tree.value;

  if (tree.left) count += sumTree(tree.left);
  if (tree.right) count += sumTree(tree.right);
  return count;
}

console.log(sumTree(binarySearchTree));
```
