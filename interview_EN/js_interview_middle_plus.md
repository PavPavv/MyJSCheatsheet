# Middle+/Senior topics

Table of content:

1. ECMASCript language, JIT Compiler, JavaScript Engine
2. Lexical and Variable environments (advanced)
3. Infinite loop (stack overflow)
4. Hoisting (advanced)
5. Temporal Dead Zone (TDZ)
6. Scope (advanced)
7. Coercion (advanced)
8. Closures (advanced)
9. Prototypes (advanced)
10. this (advanced)
11. Symbol (advanced)
12. Asynchronous JavaScript (advanced)
13. Iterators
14. Debugging
15. Data structures (todo)

## From the "Advanced JavaScript Unleashed" book written by Yousaf Khan

### 1. ECMASCript language, JIT Compiler, JavaScript Engine

In the case of JavaScript, the JavaScript engines do not output an executable file, which is one of the reasons it is thought of as an interpreted language.
However, the JavaScript code is compiled into an intermediary form known as byte code, which is then executed by the virtual machine. The virtual machine interprets byte code, but modern JavaScript engines don’t just interpret the byte code; they include what’s known as the “Just-in-time (JIT) compiler” to compile the byte code into native machine code, which is executed at a faster speed than the byte code.

Just-in-time (JIT) compilation is a technique used by many modern JavaScript engines to increase
the execution speed of the JavaScript code. Unlike traditional compilers, which compile the code ahead of time, the JIT compiler compiles the code at runtime while the code is being executed. It is safe to say that it is both - compiled as well as an interpreted language.

To execute JavaScript code, we need another software known as a JavaScript engine. This engine contains all the necessary components to transform the code into something the machine can execute.

Source TS Code -> TSC -> Source code -> Parser -> AST -> Interpreter -> Bytecode -> Compiler -> Machine Code

The engine itself doesn’t have the capability to download the code. The browser does it and the  passes it to the engine, which can then begin transforming it and eventually execute it.

After downloading the source code, the next step is to transform it into tokens.

Once the tokens have been generated, the parser uses them to generate an Abstract Syntax Tree.

The Bytecode Generator uses the AST produced by the parser to generate the bytecode. This generated bytecode is taken by the Bytecode Interpreter, which then interprets it.

While the bytecode is executed, the JavaScript engine collects information about the code being executed. The engine then uses this information to optimize the code further.

The need for falling back to the bytecode arises from the fact that JavaScript is a dynamically typed language. The optimized native machine code is generated using the information collected during the execution of the JavaScript code. The native machine code requires certain checks to ensure that the assumptions made during the generation of the native machine code are not violated. If the checks fail, the JavaScript engine has to execute the bytecode instead of the native machine code.
This process is called deoptimization.

Whenever any JavaScript code is executed, it is executed inside an environment. By “environment”, I mean everything that is accessible by the code that aids in its execution. For example, the value of this , variables in the current scope, function arguments, etc. This environment is known as the “Execution Context”. Every time any JavaScript code is executed, an execution context is created before its execution.

• Global execution context
• Function execution context
• eval()

Execution context phases: creation phase(1) and execution phase(2).

(1)During this phase, the variable declarations and references to functions are saved as key-value pairs inside the execution context. The value of this and a reference to the outer environment are also set during this phase. In the case of a global context, there is no outer environment, so reference to the outer environment
is set to null , but in the case of a function context, the value of this depends on how the function is called, so the value of this is set appropriately.

### 2. Lexical and Variable environments (advanced)

During the creation phase, the following two components are created:

- Lexical environment
- Variable environment

A call stack is a structure that is used internally by the JavaScript engine to keep track of the piece of code that is currently executing. The call stack is simply a stack²² data structure that aids in the execution of the JavaScript code by keeping track of currently executing code. You can also think of a call stack in JavaScript as a collection of execution contexts. Before executing any JavaScript code, a global execution context is created and pushed on the call stack. After pushing the global execution context on the call stack, any function calls encountered during the execution of the code will lead to more entries in the call stack. For every function call, a new entry is added to the call stack before that function starts executing, and as soon as the function execution ends, that entry is popped off the stack.

### 3. Infinite loop (stack overflow)

Remember what happens when a function is called? A new entry is added to the call stack. In the case of the above function that just calls itself and never finishes executing, we are just adding the new entries in the call stack without ever removing any entries. This is infinite recursion, and this leads to an error known as stack overflow. This error is thrown when the call stack gets filled up to its limit and can no longer hold more entries.

The official ECMAScript specification doesn’t state anything about how JavaScript engines should allocate memory for different types of values or how they should free up memory once it is no longer needed by the program. As a result, different JavaScript implementations are free to choose how they want to handle memory management in JavaScript.

JavaScript values in V8 are represented as objects and allocated on the V8 heap, no matter if they are objects, arrays, numbers, or strings. This allows us to represent any value as a pointer to an object.

### 4. Hoisting (advanced)

In JavaScript, variables and functions can be accessed before their actual declaration. The term “hoisting” is mostly associated with function declarations and variables declared with the “var” keyword. 

The JavaScript engine scans the code before executing it, allowing it to detect some errors before any code is executed. This also enables the engine to handle variable declarations by registering the variables declared in the current scope. Before any scope starts, all the variables declared in that scope are registered for that scope. In other words, all the variables declared in a scope are reserved for that scope before the code in that scope is executed. This preprocessing of the code before its
execution is what enables hoisting. Function declarations, just like variables declared using the “var” keyword, are also hoisted.

According to the standard rules, the function declarations inside blocks are hoisted to the top of the block, converted into a function expression, and assigned to a variable declared with the let keyword. The function hoisted inside the block is limited to the containing block and cannot be accessed by code outside the block containing the function.

Like function declarations, class declarations are also hoisted, but they are hoisted differently compared to the function declarations.

#### 5. Temporal Dead Zone (TDZ)

Temporal Dead Zone (TDZ) refers to the time during which the block-scoped variables ( let , const ) or class declarations cannot be accessed. The time starts from the start of the scope till the declaration is executed. TDZ is the reason class declarations cannot be accessed before their declaration is executed during
the step-by-step execution of the code. As TDZ also applies to the let and const , are the variables declared using let or constants using const also hoisted? Yes, they are also hoisted, but, like the class declarations, they are hoisted differently because of the TDZ. It is a common misconception that block-scoped variables and constants are not hoisted, but as we discussed above, they are hoisted; it’s just that their hoisting is different as compared to the hoisting of variables declared using the var keyword.

JavaScript engines don’t move the hoisted declarations to the top of the file. Instead, they simply process the declarations before the step-by-step execution of the code. In the case of var variables, they are assigned the value of undefined until their declaration is executed. In the case of block-scoped variables, they are marked as “uninitialized”.

### 6. Scope (advanced)

In JavaScript, the scope of different identifiers (variables, functions, etc.) is determined at compile time. Before the step-by-step execution of the JavaScript code starts, JavaScript engines determine the scopes of different declarations in the code.

This type of scope, which is determined at compile time by analyzing the code structure, is known as lexical scope. JavaScript is not the only language that has a lexical scope. Other languages, like Java, also have a lexical scope. Lexical scope is also known as “static” scope. An alternative type of scope is Dynamic scope.

Variables created using the var keyword or function declarations declared in the global scope are added as properties on the window object. If the todoList was declared with let or const , it wouldn’t have been added as a property on the window object, but it would still be a global variable.

Whenever there is an assignment to an undeclared variable, JavaScript will declare that undeclared variable as a global variable.

The id of the h1 element above gets added to the global scope as a variable. We can access the h1 element using the mainHeading as a variable in JavaScript code. This feature is referred to as Named access on the Window object.

```javascript
function paramScope(arr = ["initial array"], buff = () => arr) {
  var arr = [1, 2, 3];
  console.log(arr); // [1, 2, 3]
  console.log(buff()); // ["initial array"]
}
paramScope();
```

The answer is that the arr parameter and the arr variable inside the function are two different variables that exist in two different scopes. The arr inside the function shadows the arr parameter, but calling the buff function returns the parameter arr . If the parameter and the local arr were the same variable, the buff function would return [1, 2, 3] instead of the default value of the arr parameter. Remove the var keyword inside the function to show the different output:

```javascript
function paramScope(arr = ["initial array"], buff = () => arr) {
  arr = [1, 2, 3];
  console.log(arr); // [1, 2, 3]
  console.log(buff()); // [1, 2, 3]
}
paramScope();
```

### 7. Coercion (advanced)

Coercion in JavaScript is the conversion of one type of value into another type of value.
If the hint argument is “number”, then the OrdinaryToPrimitive abstract operation first invokes the valueOf method and then the toString method, if needed.

```javascript
0 == false  // true

"" == false // true

0 == [] // -> 0 == "" -> 0 == 0 -> true

[123] == 123  // "123" == 123 -> 123 == 123 -> true

[1] < [2] // true

[] == ![] // -> [] == false -> [] == 0 -> "" == 0 -> 0 == 0 -> true

!!"true" == !!"false" // true

[1, 2, 3] + [4, 5, 6] // "1,2,34,5,6"

[undefined] == 0  // true

[[]] == ''  // true

[] + {} // [object Object]
```

### 8. Closures (advanced)

The closure is a combination of the following two things:
• A Function
• A reference to the environment/scope in which that function is created

Every time a javascript function is created, a closure is formed, which allows that function to access the scope chain that was in effect when that function was defined. Each time a function is created, javascript saves the reference to the surrounding environment of the function in the internal "[[Environment]]" slot on the function object. When that function is called, a new environment is created for that function call, and javascript saves the value of [[Environment]] slot on the function in the [[OuterEnv]] slot of the environment object.
It is a common misconception among beginners that closures are only formed when any function returns a nested function. But that is not the case.
Every time a function is created in JavaScript, it forms a closure over the environment in which that function was created. Forming a closure is a fancy way of saying that when a function is created, it saves a reference to the environment in which it was created.
It is important to note that functions form closures over variables, not their values. Closure over variables implies that each function logs the latest value of the variable it has closed over.

### 9. Prototypes (advanced)

Objects in JavaScript are linked to other objects, and this linkage allows an object to use the functionality of another object to which it is linked.
When we create an object literal in JavaScript, it is, by default, linked to the built-in Object.prototype object.
Objects in JavaScript have a hidden internal slot named [[Prototype]] . When an object is created, it is linked to another object by saving a reference to the other object in the [[Prototype]] internal slot of the newly created object. The other object whose reference is saved in the internal slot will serve as the “prototype” of the newly created object.
The prototype property of a function refers to an object that is used as the “prototype” of other objects when that function is invoked as a “constructor function” using the “new” keyword.
The term “prototype” has been used in two contexts here:

- The “prototype” property on functions
- An object is referred to as a “prototype” when it is linked and shares its properties with other
objects.

```javascript
function Car(name, model) {
  this.name = name;
  his.model = model;
}
console.log(Object.getOwnPropertyNames(Car));
// [ "prototype", "length", "name" ]
console.log(Car.prototype.constructor === Car); // true
```

Initially, the object pointed to by the prototype property on any function just contains a single property named “constructor”. The value of this “constructor” property is a reference to the constructor function. In the case of Car.prototype object, Car.prototype.constructor refers to the Car constructor function.

When a function is invoked using the new keyword, one of the steps during the creation of a new object is that the [[Prototype]] internal slot of the newly created object is pointed to the object referenced by the function’s prototype property. As a result, the newly created object has access to the properties defined on the object referred to by the constructor function’s prototype property.

Accessing the prototype of Object.prototype returns null.

As of 2015, JavaScript has classes. They provide a declarative way of writing code that is less error-prone.
The two prototype chains set up by the extends keyword serve two different purposes:

- Student.prototype ---> Person.prototype allows the inheritance of the instance properties.
- Student ---> Person allows the inheritance of the static properties.

#### Inheritance before ES6

```javascript
function Employee(name, age, id) {
  this.name = name;
  this.age = age;
  this.id = id;
}
function BankEmployee(name, age, id, bankName) {
  // delegate the responsibility of adding
  // "name", "age", and "id" properties to
  // the Employee constructor
  Employee.call(this, name, age, id);
  this.bankName = bankName;
}
```

### 10. this (advanced)

In the global scope, the value of this depends on the environment in which our JavaScript code is executed. JavaScript code can be executed in different environments, for example, browsers, NodeJS, etc. The value of this in global scope is different in different environments. In the case of browsers, the value of this in the global scope is the window object.
In NodeJS, the value of this depends on whether we are using the ECMAScript modules or the CommonJS modules. In ECMAScript modules, the value of this is undefined at the top level of a module. This is because the code in ECMAScript modules is executed in strict mode. In CommonJS modules, at the top level of a module, this refers to the module.exports object. In Node.js, the JavaScript code is technically not executed in a global scope. Instead, it is executed in a module scope, where commonly used modules are CommonJS and ECMAScript modules.
Inside web workers⁹³, the value of this at the top level refers to the global scope of the web worker, which is different from the global scope containing the window object in the browser. Code inside a web worker is executed in its own separate context with its own global scope.

When a function is invoked as a constructor function using the new keyword, the this keyword inside the constructor function refers to the newly created object. The new keyword creates a new object and sets the newly created object as the value of this . As a result, we can use this inside a constructor function to add properties to the newly created object.

Code inside a class in JavaScript is executed in strict mode. As a result, the value of this inside methods is either undefined if not invoked on an object or the class instance itself, which is used to invoke the method.

The event listener callback is invoked with this set to the HTML element that triggered the event.

const btn = document.querySelector("button");

```javascript
class FormHandler {
  constructor(submitBtn) {
    submitBtn.addEventListener("click", this.submitForm);
  }

  submitForm() {
    console.log("form submitted");
    console.log(this);
    // The value of this inside this method,
    // when it is invoked as an event listener callback, is the button element and not the instance of the
    // class like we would normally expect.
  }

}
new FormHandler(btn);
```

Assuming that our code is in non-strict mode, the value of this inside the increment5 function is the global object, i.e., the window object in the case of browsers. So,
this.value is actually window.value , and it is undefined because the window object, by default, doesn’t have a value property. As a result, we get the NaN value
when undefined is added to a number, i.e., the value of the incrementStep parameter.

```javascript
function Counter(startingValue) {
  this.value = startingValue;
}

Counter.prototype.incrementFactory = function (incrementStep) {
  return function () {
    this.value += incrementStep;
    console.log(this.value);
  };
};
const counter = new Counter(0);
const increment5 = counter.incrementFactory(5);
increment5(); // NaN
increment5(); // NaN
increment5(); // NaN
```

There are multiple ways to handle this problem. One way is to save the value of this inside the incrementFactory function before returning a function, and inside
the returned function, use the variable containing the value of this instead of directly using this .

```javascript
function Counter(startingValue) {
  this.value = startingValue;
}
Counter.prototype.incrementFactory = function (incrementStep) {
  const thisVal = this; // save `this` value
  return function () {
    // use `thisVar` variable instead of `this`
    thisVal.value += incrementStep;
    console.log(thisVal.value);
  };
};
const counter = new Counter(0);
const increment5 = counter.incrementFactory(5);
increment5(); // 5
increment5(); // 10
increment5(); // 15
```

Another way to solve the problem shown above is to use an arrow function.

```javascript
function Counter(startingValue) {
  this.value = startingValue;
}
Counter.prototype.incrementFactory = function (incrementStep) {
  // use an arrow function
  return () =>  {
    thisVal.value += incrementStep;
    console.log(thisVal.value);
  };
};
const counter = new Counter(0);
const increment5 = counter.incrementFactory(5);
increment5(); // 5
increment5(); // 10
increment5(); // 15
```

```javascript
function Counter(startingValue) {
  this.value = startingValue;
}

Counter.prototype.incrementFactory = function (incrementStep) {
  const incrementFn = function () {
    this.value += incrementStep;
    console.log(this.value);
  };
  // return a function with `this` bound
  // to the object used to invoke the
  // `incrementFactory` method
  return incrementFn.bind(this);
};

const counter = new Counter(0);
const increment5 = counter.incrementFactory(5);
increment5(); // 5
increment5(); // 10
increment5(); // 15
```

Using an arrow function solves the problem because, unlike regular functions, which get their own value of this when they are invoked, arrow functions don’t
get their own this value; instead, the value of this inside an arrow function is taken from the surrounding context.
The surrounding context is the environment in which the arrow function is defined. In our code example, the arrow function is created when the incrementFactory
function is invoked using the this keyword counter object. So, this inside the incrementFactory function refers to the counter object, and this
is the surrounding context of the arrow function returned from the incrementFactory function. As a result, the value of this inside the arrow function, when
it is invoked, is also the counter object.

```javascript
class FormHandler {
  constructor(submitBtn) {
    submitBtn.addEventListener("click", () => this.submitForm());
  }

  submitForm() {
    console.log("form submitted");
    console.log(this);
    // The value of this inside this method,
    // when it is invoked as an event listener callback, is the button element and not the instance of the
    // class like we would normally expect.
  }

}
new FormHandler(btn);
```

The reason an arrow function fixed the issue is that, as discussed earlier, arrow functions do not have their own value of this ; they get it from the surrounding
environment. The surrounding environment is the constructor in this case. What’s the value of this inside the constructor? Its value is an instance of the FormHandler
class when the constructor is invoked using the new keyword.

How React fixed this problem before hooks (before v16.8):

```javascript
class FormHandler {
  constructor(submitBtn) {
    submitBtn.addEventListener("click", this.submitForm.bind(this));
  }

  submitForm() {
    console.log("form submitted");
    console.log(this);
  }
}
```

#### Borrowing methods

```javascript
const john = {
  name: "John",
  sayHello() {
    console.log("Hello, I am " + this.name);
  },
};

const pav = {
  name: "Pav",
};

// borrow method from john
const sayHello = john.sayHello;
sayHello.call(pav);
// Hello, I am Pav
```

#### globalThis

globalThis is a globally available property in JavaScript that allows us to access the global object regardless of which environment our JavaScript code is executed in.
It provides us with a standard way to access the global object across different JavaScript environments.

```javascript
// before
if (typeof window !== "undefined" && window.secretProperty) {
  // execute code for browser
} else if (typeof global !== "undefined" && global.secretProperty) {
  // execute code for Node.js
}

// now
if (globalThis.secretProperty) {
  // execute code
}
```

### 11. Symbol (advanced)

Symbols allow JavaScript to add new properties to objects that cannot conflict with the existing properties on objects that others might have used in their code.

Symbol values can be created using the Symbol function. It’s important to note that the Symbol
function must be invoked without the new keyword. Attempting to use the new keyword to invoke
the Symbol function will result in an error. This is because it prevents the creation of an object
wrapper around the symbol. Every call to the Symbol function must create a new unique symbol
value.

```javascript
const sym = Symbol();

const obj = {};
obj[sym] = "hello";

// or

const obj = {
  [sym]: "hello"
};

console.log(obj[sym]); // "hello"
console.log(obj["sym"]); //  undefined
console.log(obj.sym); //  undefined
```

Symbol properties can be discovered using methods like Object.getOwnPropertyDescriptors or Object.getOwnPropertySymbols .
JavaScript has true private properties, and symbols are not intended to be used as private properties.

The description is passed as an argument to the Symbol function. The provided description can then
be accessed using the property named description on symbols. The description property can only be used to get the property of a symbol; it cannot be used to
set the description.

```javascript
const propSymbol = Symbol("property symbol");
console.log(propSymbol.description);
// property symbol
```

Symbol.toPrimitive represents a symbol property that is used by the object to primitive conversion process in JavaScript. Its value is a function that
is passed a hint or the preferred type of the primitive value to represent the object being converted into a primitive value. The return value is used as the primitive value of the object.

```javascript
const movie = {
  name: "Jurassic Park",
  releaseDate: "09,June,1993",
  [Symbol.toPrimitive](hint) {
    if (hint === "number") {
      return new Date(this.releaseDate).getTime();
    } else {
      return this.name;
    }
  }
};

console.log(Number(movie));
console.log(String(movie));

const task = {
  title: "exercise",
  isComplete: false,
  [Symbol.toStringTag]: "Task"
};
console.log(task.toString()); // [object Task]
```

### 12. Asynchronous JavaScript (advanced)

#### Callbacks

```javascript
function main() {
  function fetchData(err, cb) {
    const isOk = false;
    const error = 'Somwthing went wrong';
    const data = [
      {
        id: 1,
        name: "Jack",
      },
      {
        id: 2,
        name: "Mag",
      },
    ];
    setTimeout(function() {
      if (isOk) {
        cb(data);
      } else {
        err(error);
      }
    }, 2000);
  }

  function onError(err) {
    console.log(err);
  }

  function onSuccess(data) {
    console.log(data);
  }

  console.log(fetchData(onError, onSuccess));
}
main();
```

>> JavaScript also allows us to execute some code in another thread, independent of the main thread, using the web workers.

As we know already, the JavaScript language is single-threaded. Long-running code on the main thread can block the thread; in the case of browsers,
blocking the main thread means that browsers cannot respond to user interactions and cannot render changes on the UI. This is why the screen
freezes when some long-running code blocks the main thread. In the case of NodeJs, in the context of application servers, blocking the main thread means
that the server cannot handle the incoming HTTP requests until the main thread is unblocked.

#### Event loop

The event loop helps to execute asynchronous operations in a non-blocking manner. When an asynchronous operation is completed in the background to execute
the JavaScript callback that we provided at the time of initiating the asynchronous operation, it needs to be pushed onto the call
stack. The call stack is a stack data structure used to keep track of the currently executing code. Every function call is added to the stack as a stack frame.
The frame is popped off the stack when the function execution ends.

> No asynchronous callback can be invoked until the synchronous execution of the code has ended. Remember, only one thing executes at a time on the main thread, and the currently executing code cannot be interrupted.

Any user interaction like the click event requires scheduling a task; the same is true for executing the callbacks of timing functions like setTimeout . Tasks are queued in the task queue until the event loop processes them. The task queue is also referred to as the event queue or the callback queue.

The event loop processes a single task during its single turn, commonly referred to as the “event loop tick” or just “tick”. The next task is processed during the next turn or tick of the event loop. The browser may choose to render UI updates between tasks.

Whereas “tasks” are executed in the order they are enqueued in the task queue, only one task is executed per one turn or tick of the event loop.

Another important thing to note about microtasks is that while only one task is processed per tick of the event loop, microtasks are processed until the microtask queue is empty. If a task schedules another task, it won’t be processed until the next turn or tick of the event loop, but in the case of microtasks, if any microtask is queued by a microtask, the queued microtask will also be processed.
This means that the event loop can get stuck in an infinite loop if each microtask keeps queuing another microtask.

#### Promises

Promises can be in one of the following three states in their lifecycle:

- pending: the initial state in which promises typically start when they are created. It indicates that the asynchronous operation associated with the promise is in progress.

- fulfilled: means that the asynchronous operation associated with the promise has been completed successfully.

- rejected: means that the asynchronous operation associated with the promise has failed.

During the lifecycle of a promise, its state changes from pending to either fulfilled or rejected. The state of a promise is saved in the hidden internal slot named [[PromiseState]]. A promise in the pending state is considered unsettled. Once the promise transitions from the pending state into either a fulfilled or rejected state, it is said to have settled.

There are three instance methods we can call on promise instances:

- Promise.prototype.then()

- Promise.prototype.catch()

- Promise.prototype.finally()

```javascript
function main() {
  function fetchData() {
    const isOk = true;
    const error = 'Somwthing went wrong';
    const data = [
      {
        id: 1,
        name: "Jack",
      },
      {
        id: 2,
        name: "Mag",
      },
    ];
    return new Promise((res, rej) => {
      if (isOk) {
        setTimeout(() => {
          res(data);
        }, 2000);
      } else {
        setTimeout(() => {
          rej(error);
        }, 2000);
      }
    })
  }  

  fetchData()
    .then((response) => {
      console.log(response);
    })
    .catch((error) => {
      console.log(error);
    });

    // custom "catch"
    // fakeRequest().then(null, (error) => {
    // // handle error
    // });
}
```

The Promise constructor takes a callback function as an argument, referred to as the executor function, that is invoked synchronously to create the promise object.
It is common to incorrectly assume that any code inside the executor function is executed asynchronously, but that is not the case. The executor function is invoked
synchronously to create the promise object. The code inside the executor function should be any code that starts some asynchronous operation. The newly
created promise object will observe that asynchronous operation. The promise object will notify us about the success or failure of the asynchronous operation that is
initiated inside the executor function.

```javascript

const url1 = "https://jsonplaceholder.typicode.com/todos/1";
const url2 = "https://jsonplaceholder.typicode.com/todos/2";
const url3 = "https://jsonplaceholder.typicode.com/todos/3";

function parseFetchResponse(response) {
  if (response.ok) {
    return response.json();
  } else {
    throw new Error("request failed");
  }
}
Promise.all([
  fetch(url1).then(parseFetchResponse),
  fetch(url2).then(parseFetchResponse),
  fetch(url3).then(parseFetchResponse)
])
  .then((dataArr) => {
    console.log(dataArr);
  })
  .catch((error) => console.log(error.message))


// returns a promise that is fulfilled
// after approximately 1 second
function promisifiedRandomNumber() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // generate a random number within range: 0 - 9
      const randomNum = Math.floor(Math.random() * 10);
      resolve(randomNum);
    }, 1000);
  });
}
async function random() {
  const promiseArr = [
    promisifiedRandomNumber(),
    promisifiedRandomNumber(),
    promisifiedRandomNumber()
  ];
  const randomNumsArr = await Promise.all(promiseArr);
  console.log(randomNumsArr);
}
random();
```

#### Async/await

```javascript
async function foo() {
  return 123;
}
foo().then(console.log); // 123
```

```javascript
async function foo() {}
foo().then(console.log); // undefined
```

What’s important to note is that the code inside the async function is executed synchronously until the first await expression.

```javascript
// returns a promise that is fulfilled
// after approximately 1 second
function promisifiedRandomNumber() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // generate a random number within range: 0 - 9
      const randomNum = Math.floor(Math.random() * 10);
      resolve(randomNum);
    }, 1000);
  });
}
async function random() {
const promiseArr = [
  promisifiedRandomNumber(),
  promisifiedRandomNumber(),
  promisifiedRandomNumber()
];
const randomNumsArr = await Promise.all(promiseArr);
console.log(randomNumsArr);
}
random();
```

The await keyword is usually used to wait for a promise to settle, but it can also be used with a non-promise value.

### 13. Iterators

Iterable is an object that implements the [iterable protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol). According to the iterable protocol, an object is iterable if it defines the iteration behavior that can be used by the for...of loop to iterate over the values in the object. The object can implement a method that is referred to by the property represented by Symbol.iterator133; it is one of the well-known symbols to define the iteration behavior.

Iterators are objects that implement the iterator protocol134. According to the iterator protocol, an object is an iterator if it implements a method named next that takes zero or one argument and returns an object with the following properties: "done" and "next".

```javascript
const arr = [2, 4, 6, 8, 10];

// get the array iterator object
const arrayIterator = arr[Symbol.iterator]();

// get the first iterator result object
let result = arrayIterator.next();

// keep getting new iterator result objects
// until the "done" property of the iterator
// result object is false
while (!result.done) {
  console.log(result.value);
  result = arrayIterator.next();
}
```

Each iterator object inherits from the respective iterator prototype object. For example, the array iterator inherits from the Array Iterator prototype object. Similarly, the string iterator inherits from the String Iterator prototype object. All iterator prototype objects inherit from the Iterator.prototype object.

```javascript
function Student(name, age, id, courses) {
  this.name = name;
  this.age = age;
  this.id = id;
  this.courses = courses;
}

Student.prototype[Symbol.iterator] = function () {
  // "this" refers to the student object on which this method is called
  const currentStudent = this;
  const studentProps = Object.getOwnPropertyNames(currentStudent);
  let propIndex = 0;

  const studentIterator = {
    next: () => {
      if (propIndex < studentProps.length) {
        const key = studentProps[propIndex];
        const value = currentStudent[key];
        propIndex++;
        const formattedValue = `${key.padStart(7)} => ${value}`;

        return {
          value: formattedValue,
          done: false
        };
      }
      return {
        value: undefined,
        done: true
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
  return studentIterator;
};


const jack = new Student("Jack", 20, "21A", ["Maths", "Biology", "Physics"]);
for (const val of jack) {
  console.log(val);
}
/*
  name => Jack
  age => 20
  id => 21A 
  courses => Maths,Biology,Physics
*/
```

### 14. Debugging

The debugger statement allows us to set up a point in our code where the debugger can pause the execution of our code. This is like setting up breakpoints in our code where the code execution can be paused, allowing us to inspect the values of different variables in our code.

---------------------------------------------------------------------------------------

## 15. Data structures (todo)

Linear data structures are simple in direction. A linked list is a list of nodes (each containing their own data) that are linked from one node to the next (and to the previous, for a doubly linked list). A stack builds upward like a tower of data. Each node stacking atop another, and shortens in a last in first out (LIFO) manner. A queue is a line of nodes that elongate from the end of the line and shortens in a first in first out (FIFO) mechanism.

Binary data structures are like a fork in a road of data. The nodes build like the branches of a tree or a heap of rocks.

### Binary Search Tree

Compared to a normal tree, BST has the following properties:

- every left child has a smaller value than its parent
- every right child has a larger value than its parent
- every node can contain from 0 to 2 children

```javascript
const binarySearchTree = {
  value: 4,

  left: {
    value: 2,
    left: {
      value: 1,
    },
    right: {
      value: 3,
    },
  },

  right: {
    value: 5,
    right: {
      value: 6,
    },
  },
};

function sumTree(tree) {
  let count = tree.value;

  if (tree.left) count += sumTree(tree.left);
  if (tree.right) count += sumTree(tree.right);
  return count;
}

console.log(sumTree(binarySearchTree));
```
