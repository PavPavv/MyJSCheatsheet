# Вопросы и ответы на собеседовании по JavaScript (базовый уровень)

## Типы данных в JS

В JS существует **8** типов данных: 7 примитивов (**boolean**, **string**, **number**, **bigInt**, **Symbol**, **undefined**, **null**) и
1 ссылочный тип: **object**. Также в JS есть такое понятие, как псевдоложные значения, которые при привидении их к булевому типу
вернут _false_. Их тоже 7, как и примитивных типов: **false**, **0**, **-0**, **''**, **undefined**, **null** и **NaN**.

## Чем отличается undefined от null

**undefined** представляет собой значение по умолчанию:

- переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;
- функции, которая ничего не возвращает явно, например, _console.log(1)_;
- несуществующего свойства объекта;

**null** — это «значение отсутствия значения». Это значение, которое присваивается переменной явно.
При сравнении **null** и **undefined** мы получаем _true_, когда используем оператор "==", и _false_ при использовании оператора "===" (сравнение по типу).

## Оператор логическое 'И' **&&**

Может применяться как аналог управляющей инструкции **if**, так как **&&** находит и возвращает первое ложное значение, либо последний операнд, когда все значения истинные. Он использует замыкание во избежание лишних затрат.

```javascript
true && console.log("Вывод");
```

Такой код вернет "Вывод".
Основные логические операторы в JS - **&&**, **||** (логическое "ИЛИ"), **!** (логическое отрицание ("НЕ")).
Оператор **&&** старше, чем **||**.

## Виды преобразований в JS

- ToBoolean
- ToString
- ToNumber
- ToPrimitive
- JSON.stringify() - не совсем преобразование

###### ToBoolean

Кроме 7 псевдоложных значений, все _true_.
К булеву типу в JS приводят:

- **Boolean()**
- **!!** (двойное отрицание),
- конструкции и циклы **if**, **for**, **while**, **do/while**,
- тернарный оператор **? :**,
- операторы сравнения **&&** (левая часть), **||**

###### ToString

**''**, **""**, **``**, stringType + something, **String()**, **toString()**

###### ToNumber

+,-, **Number()**, **parseInt()**

true/false == 1/0\
'' == 0

```javascript
let test = undefined + 5;
console.log(test);
console.log(typeof test);
```

\*Вернет **NaN** и тип будет **number\***

```javascript
let test = 8 * null;
console.log(test);
console.log(typeof test);
```

\*Вернет **0** и тип будет **number\***

###### ToPrimitive

valueOf -> toString()

## Почему _setTimeot_ выполнится после основного кода, если у него нулевая задержка?

```javascript
setTimeout(() => {
  console.log("Print something else");
}, 0);
console.log("Print something");
```

В браузере есть минимальная задержка в 4 миллисекунды при вызове _setTimeout_.

## В чем разница между spread-оператором и rest-оператором?

Операторы **spread** и **rest** имеют одинаковый синтаксис ("..."). Разница состоит в том, что с помощью **spread** мы передаем или распространяем данные массива на другие данные, а с помощью **rest** — получаем все параметры функции и помещаем их в массив (или извлекаем часть параметров).

## Что такое объектная обертка (Wrapper Objects)?

Такие примитивы как строка, число, boolean имеют свойства и методы, несмотря на то, что они не являются объектами.
Причина такого поведения заключается в том, что примитив временно преобразуется в объект. У каждого примитива, кроме null и undefined, есть объект-обертка. Такими объектами являются String, Number, Boolean, Symbol и BigInt. Временный объект отбрасывается по завершении работы со свойством или методом.

## Как определить наличие свойства в объекте?

1.

```javascript
const o = {
  prop: "bwahahah",
  prop2: "hweasa",
};
console.log("prop" in o); // true
console.log("prop1" in o); // false
```

2.

```javascript
console.log(o.hasOwnProperty("prop2")); // true
console.log(o.hasOwnProperty("prop1")); // false
```

3. индексная нотация массива:

```javascript
console.log(o["prop"]); // bwahahah
console.log(o["prop1"]); // undefined
```

Оператор **\*in** проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод **hasOwnProperty** — только в объекте.

## Как в JS создать объект?

1. Объектный литерал:

```javascript
const o = {
  name: "Mark",
  greeting() {
    return `Hi, I'm ${this.name}`;
  },
};
o.greeting; // Hi, I'm Mark
```

2. Функция-конструктор:

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greeting = function () {
  return `Hi, I'm ${this.name}`;
};

const mark = new Person("Mark");
mark.greeting(); // Hi, I'm Mark
```

3. Метод Object.create:

```javascript
const n = {
  greeting() {
    return `Hi, I'm ${this.name}`;
  },
};

const o = Object.create(n);
o.name = "Mark";
console.log(o.greeting); // Hi, I'm Mark
```

## Как в JS скопировать объект?

1. Object.assign(target):

```javascript
const obj = {
  name: "Paul",
  age: 27,
  favorites: {
    band: "Beirut",
    girls: "brunette",
    car: "Peugeot",
    movies: ["Office", "Ace Ventura", "Under Great White Northern Lights"],
  },
};
const obj1 = Object.assign(obj);
```

но тогда два объекта связаны по ссылке друг с другом, изменится один, изменится и другой.

2. Spread-оператор:

```javascript
const obj = {
  name: "Paul",
  age: 27,
  favorites: {
    band: "Beirut",
    girls: "brunette",
    car: "Peugeot",
    movies: ["Office", "Ace Ventura", "Under Great White Northern Lights"],
  },
};
const obj1 = { ...obj };
```

тут объекты никак не связаны друг с другом, создается независимая копия.

3. Метод Object.create:

```javascript
const obj = {
  name: "Paul",
  age: 27,
  favorites: {
    band: "Beirut",
    girls: "brunette",
    car: "Peugeot",
    movies: ["Office", "Ace Ventura", "Under Great White Northern Lights"],
  },
};
const obj3 = JSON.parse(JSON.stringify(obj2));
```

также объекты никак не связаны друг с другом, создается независимая копия типа string

## Как в JS смержить объекты?

1. Object.assign(targetObj, obj1, obj2...):

```javascript
const state = {
  number: 1,
  club: "Arsenal",
};

const newS = {
  year: "2021",
};

const m1 = Object.assign(state, newS);
```

но тогда объекты связаны по ссылке друг с другом, изменится один, изменится и другой.

2. Spread-оператор:

```javascript
const state = {
  number: 1,
  club: "Arsenal",
};

const newS = {
  year: "2021",
};

const m2 = {
  ...state,
  ...newS,
};
```

тут объекты никак не связаны друг с другом, создается новая независимая копия.

3. Для глубокой копии потребуется кастомное рекурсивное решение:

```javascript
const merge = (...arguments) => {
  // create a new object
  let target = {};

  // deep merge the object into the target object
  const merger = (obj) => {
    for (let prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        if (Object.prototype.toString.call(obj[prop]) === "[object Object]") {
          // if the property is a nested object
          target[prop] = merge(target[prop], obj[prop]);
        } else {
          // for regular property
          target[prop] = obj[prop];
        }
      }
    }
  };

  // iterate through all objects and
  // deep merge them with target
  for (let i = 0; i < arguments.length; i++) {
    merge(arguments[i]);
  }

  return target;
};

const profile = {
  name: "John Doe",
  age: 25,
  address: {
    city: "Berlin",
    country: "DE",
  },
};

const job = {
  profession: "IT Engineer",
  skills: ["JavaScript", "React", "Node"],
};

// perform deep merge
const user = merge(profile, job);

console.log(user);

// {
//     name: 'John Doe',
//     age: 25,
//     address: { city: 'Berlin', country: 'DE' },
//     profession: 'IT Engineer',
//     skills: ['JavaScript', 'React', 'Node']
// }
```

## Что такое DOM?

Document Object Model - это API браузера для работы с HTML- и XML-документами.
DOM представляет собой древовидную структуру (дерево документа). DOM используется
для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.

## В чем разница между event.target и event.currentTarget

**event.target** — это элемент, на котором происходит событие, или элемент, вызвавший событие.
**event.currentTarget** — это элемент, к которому прикреплен обработчик событий.

## Чем отличаются "==" и "==="

"==" сравнивает с неявным приведеннием к типу, "===" сравнивает по типу.
Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная.

## Способы назначения обработчиков событий

Есть три способа назначения обработчиков событий:

- Атрибут HTML: _onclick="..."_.
- DOM-свойство: _elem.onclick = function_.
- Специальные методы: _elem.**addEventListener**(event, handler[, phase])_ для добавления, removeEventListener для удаления.
  Не важно, как вы назначаете обработчик – он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло: _function(event)_

## Что такое всплытие события?

Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента,
пока не достигает объекта Window.

## Что такое поднятие (Hoisting)?

Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.
В фазе компиляции функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined
поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода.
Это объясняет, почему мы можем вызывать функции до их объявления. В фазе выполнения переменным присваиваются значения, а функции
(или методы объектов) вызываются или выполняются.
_Поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова **«var»**._

## Область видимости

Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости:
глобальная, функциональная и блочная (ES6).
**Глобальная** область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости
и доступны из любого места в коде.
**Функциональная** область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции,
доступны только внутри этой функции.
**Блочная** область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.

Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости,
ее поиск производится выше, во внешней по отношению к текущей области видимости (замыкание). Если и во внешней области видимости переменная отсутствует, ее
поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет
— выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной.
Это называется цепочкой областей видимости (Scope Chain).
Изнутри наружу: дети видят родителей, родители не видят детей.

## Замыкание (Closure)

Замыкание - это функция, использующая переменные из внешней области видимости. По сути, это функция внутри функции.
Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами,
замыкание даёт вам доступ к Scope внешней функции из внутренней функции. В JavaScript замыкания создаются каждый
раз при создании функции, во время её создания.
**Замыкание — это когда функция может запомнить и иметь доступ к своей лексической области видимости даже тогда, когда она вызывается вне своей лексической области видимости.**

##### Более подробно:

В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект,
называемый лексическим окружением LexicalEnvironment. Объект лексического окружения состоит из двух частей:

- Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
- Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

**Переменная – это просто свойство специального внутреннего объекта: Environment Record. Получить или изменить переменную», означает,**
**получить или изменить свойство этого объекта**.

Один вызов – одно лексическое окружение. Лексическое окружение – это специальный внутренний объект.
Все функции «при рождении» получают скрытое свойство **[[Environment]]**, которое ссылается на лексическое окружение места, где они были созданы.

## Пример работы use strict

- Нельзя присваивать значения или обращаться к необъявленным переменным
- Запрещено присваивать значения глобальным переменным, доступным только для чтения или записи
- Нельзя удалить «неудаляемое» свойство объекта
- Запрещено дублирование параметров
- Нельзя создавать функции с помощью функции eval
- Значением «this» по умолчанию является undefined
- Нельзя содавать новые инстансы класса без ключевого слова **new**
- прочее...

## This

this - это объект перед точкой. Значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this.
Для доступа к информации внутри объекта метод может использовать ключевое слово this. Значение this – это объект «перед точкой»,
который использовался для вызова метода. В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования.
Значение this вычисляется во время выполнения кода и зависит от контекста. Вызов без объекта: this == undefined. Стрелочные функции особенные:
у них нет своего «собственного» this. Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.
В JavaScript this является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен,
а зависит от того, какой объект вызывает метод (какой объект стоит «перед точкой»).

Проблему потери контекста (this) можно решить через замыкание (self = this) или с помощью встроенных методов call, apply, bind.

## Прототип объекта

Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор,
пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится Object.prototype. В двух словах, прототип
— это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из
способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS. В JavaScript объекты имеют
специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект
называется «прототип».
Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его.

- \***\*proto\*\*** исторически обусловленный геттер/сеттер для [[Prototype]]
- **prototype**

Как мы помним, новые объекты могут быть созданы с помощью функции-конструктора **new**. Если в F **.prototype** содержится объект, оператор **new**
устанавливает его в качестве **[[Prototype]]** для нового объекта. У каждой функции по умолчанию уже есть свойство "prototype". По умолчанию **prototype**
– объект с единственным свойством **constructor**, которое ссылается на функцию-конструктор.

## Как создать объект, не имеющий прототипа?

```javascript
const o1 = {};
console.log(o1.toString); // [object Object]
// в качестве первого параметра методу Object-create передается объект-прототип
const o2 = Object.create(null);
// нам не нужен объект-прототип, поэтому передаем null
console.log(o2.toString); // o2.toString is not a function
```

## Что нового привнес в JS стандарт ES6 или ECMAScript2015?

- Стрелочные функции (Arrow Functions).
- Классы (Classes).
- Шаблонные строки (Template Strings).
- Расширенные объектные литералы (Enhanced Object literals).

```javascript
let obj = {
  someValue,
};
```

- Деструктуризация (Destructuring).
- Промисы (Promises).
- Генераторы (Generators).
- Модули (Modules).
- Symbol.
- Прокси (Proxies).
- Множества (Sets).
- Параметры по умолчанию.
- Операторы rest и spread.
- Блочная область видимости (ключевые слова «let» и «const»).

## Что такое IIFE?

IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания
IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок.
Это выглядит так: **(function(){})()**.

## Call, apply, bind

1. **Call** используется для привязки определенного объекта к значению this вызываемой функции.

```javascript
const details = {
  message: "Hello World!",
};
function getMessage() {
  return this.message;
}
getMessage.call(details); // Hello World!
```

2. Единственное отличие **apply** от **call** состоит в том, что в **apply** аргументы передаются в виде массива, в том, как мы передаем аргументы в вызываемой функции. В apply аргументы передаются в виде массива, в call — через запятую.

```javascript
const details = {
  message: "Hello World!",
};
function getMessage() {
  return this.message;
}
getMessage.apply(details); // Hello World!
```

3. **bind** возвращает новую функцию, значением _this_ которой является объект, указанный в качестве первого параметра. В отличие от **bind**, **call** и **apply** сразу же вызывают функцию.

```javascript
import React from "react";

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: "",
    };
    this.handleChange = this.handleChange.bind(this);
    // привязываем метод handleChange к компоненту MyComponent
  }

  handleChange(e) {
    // код
  }

  render() {
    return (
      <>
        <input
          type={this.props.type}
          value={this.state.value}
          onChange={this.handleChange}
        />{" "}
      </>
    );
  }
}
```

## Что такое функциональное программирование и какие особенности JS

## позволяют говорить о нем как о функциональном языке программирования?

Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются.
Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования.

## Что такое функции высшего порядка (Higher Order Functions)?

Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента.

```javascript
function higherOrderFunction(param, callback) {
  return callback(param);
}
```

## Почему функции в JS - объекты первого класса (First-class Objects)

Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.

## Что такое классы (Classes)?

Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование:

```javascript
// ES5
function Person(firstName, lastName, age, address) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.age = age;
  this.address = address;
}

Person.self = function () {
  return this;
};

Person.prototype.toString = function () {
  return "[object Person]";
};

Person.prototype.getFullName = function () {
  return this.firstName + " " + this.lastName;
};

// ES6
class Person {
  constructor(firstName, lastName, age, address) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
    this.address = address;
  }

  static self() {
    return this;
  }

  toString() {
    return "[object Person]";
  }

  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

Переопределение методов и наследование от другого класса:

```javascript
// ES5
Employee.prototype = Object.create(Person.prototype);

function Employee(firstName, lastName, age, address, jobTitle, yearStarted) {
  Person.call(this, firstName, lastName, age, address);
  this.jobTitle = jobTitle;
  this.yearStarted = yearStarted;
}

Employee.prototype.describe = function () {
  return `I am ${this.getFullName()} and I have a position of ${
    this.jobTitle
  } and I started at ${this.yearStarted}}`;
};

Employee.prototype.toString = function () {
  return "[object Employee]";
};

// ES6
class Employee extends Person {
  // наследуемся от Person
  constructor(firstName, lastName, age, address, jobTitle, yearStarted) {
    super(firstName, lastName, age, address);
    this.jobTitle = jobTitle;
    this.yearStarted = yearStarted;
  }

  describe() {
    return `I am ${this.getFullName()} and I have a position of #{this.jobTitle} and I started at ${
      this.yearStarted
    }}`;
  }

  toString() {
    // переопределяем метод toString класса Person
    return "[object Employee]";
  }
}
```

## Что такое функция обратного вызова (Callback Function)?

Функция обратного вызова — это функция, вызов которой отложен на будущее (происходит при некоторых условиях, например, при наступлении события).

## Что такое промисы (Promises)?

Промисы — это один из приемов работы с асинхронным кодом в JS. Они возвращают результат асинхронной операции. Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова».
У промиса есть четыре состояния:

- Ожидание (penging) — начальное состояние промиса. Результат промиса неизвестен, поскольку операция не завершена.
- Выполнено (fulfilled) — асинхронная операция выполнена, имеется результат.
- Отклонено (rejected) — асинхронная операция не выполнена, имеется причина.
- Завершено (resolved) — выполнено или отклонено.

Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова.

```javascript
// промис
function callApi() {
  return fetch("url/to/api/endpoint")
    .then((resp) => resp.json())
    .then((data) => {
      // работаем с данными
    })
    .catch((err) => {
      // работаем с ошибкой
    });
}

// async/await
// для перехвата ошибок используется try/catch
async function callApi() {
  try {
    const resp = await fetch("url/to/api/endpoint");
    const data = await res.json();
    // работаем с данными
  } catch (e) {
    // работаем с ошибкой
  }
}
```

Использование ключевого слова «async» перед функцией заставляет ее возвращать промис.

## Что такое запоминание или мемоизация (Memoization)?

Мемоизация — это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов.

## Событийный цикл (Event Loop)

### Макрозадачи

Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.

Общий алгоритм движка:\
**1**.Пока есть задачи:

- выполнить их, начиная с самой старой.\
  **2**. Бездействовать до появления новой задачи, а затем перейти к пункту 1.

Задачи поступают на выполнение – движок выполняет их – затем ожидает новые задачи (во время ожидания практически не нагружая процессор компьютера).
Может так случиться, что задача поступает, когда движок занят чем-то другим, тогда она ставится в очередь. Очередь, которую формируют такие задачи, называют «очередью макрозадач» (macrotask queue, термин v8). Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл» (FIFO).

- Рендеринг (отрисовка страницы) никогда не происходит во время выполнения задачи движком. Не имеет значения, сколь долго выполняется задача. Изменения в DOM отрисовываются только после того, как задача выполнена.
- Если задача выполняется очень долго, то браузер не может выполнять другие задачи, обрабатывать пользовательские события, поэтому спустя некоторое время браузер предлагает «убить» долго выполняющуюся задачу. Такое возможно, когда в скрипте много сложных вычислений или ошибка, ведущая к бесконечному циклу.

### Микрозадачи

Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса. Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.

_Сразу после каждой МАКРОзадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую МАКРОзадачу или отобразить изменения на странице, или сделать что-то ещё._

```javascript
setTimeout(() => alert("timeout"));

Promise.resolve().then(() => alert("promise"));

alert("code");
```

_Какой здесь будет порядок?_

1. _code_ появляется первым, т.к. это обычный синхронный вызов.
2. _promise_ появляется вторым, потому что **.then** проходит через очередь микрозадач и выполняется после текущего синхронного кода.
3. _timeout_ появляется последним, потому что это макрозадача с минимальной задержкой 4мс.

Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче! Это важно, так как гарантирует, что общее окружение остаётся одним и тем же между микрозадачами – не изменены координаты мыши, не получены новые данные по сети и т.п.

**Более подробный алгоритм событийного цикла (хоть и упрощённый в сравнении со спецификацией):**

1. Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
2. Исполнить все микрозадачи:
   - Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
3. Отрисовать изменения страницы, если они есть.
4. Если очередь макрозадач пуста – подождать, пока появится макрозадача.
5. Перейти к шагу 1.

Чтобы добавить в очередь новую макрозадачу:
Используйте setTimeout(f) с нулевой задержкой. Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей.
Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено).

**Для добавления в очередь новой микрозадачи:**
Используйте queueMicrotask(f).
Также обработчики промисов выполняются в рамках очереди микрозадач.
События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.
Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения.
